% !TEX root = main.tex

\chapter{Formalization}
\label{ch:Formalization}
\noindent



\newcommand{\seq}[1]{#1^*}



%% font definitions

\renewcommand{\symbol}[1]{\textbf{#1}}
\newcommand{\helper}[1]{\textsf{#1}}
\newcommand{\premise}[1]{\textsf{\textbf{#1}}}

% Algorithm
\newcommand{\rel}{\symbol{Rel}}
\newcommand{\fun}{\symbol{Fun}}

% Continuation
\newcommand{\mt}{\symbol{Empty}}
\newcommand{\toplevelcall}{\symbol{TopLevelCall}}
\newcommand{\call}{\symbol{Call}}
\newcommand{\wasm}{\symbol{Wasm}}
\newcommand{\exe}{\symbol{Execute}}
\newcommand{\algo}{\symbol{Algo}}
\newcommand{\ret}{\symbol{Return}}

% Instruction
\newcommand{\ifi}{\symbol{IfI}}
\newcommand{\eitheri}{\symbol{EitherI}}
\newcommand{\enteri}{\symbol{EnterI}}
\newcommand{\pushctxi}{\symbol{PushCtxI}}
\newcommand{\pushi}{\symbol{PushI}}
\newcommand{\popctxi}{\symbol{PopCtxI}}
\newcommand{\popi}{\symbol{PopI}}
\newcommand{\popni}{\symbol{PopNI}}
\newcommand{\popalli}{\symbol{PopAllI}}
\newcommand{\leti}{\symbol{LetI}}
\newcommand{\trapi}{\symbol{TrapI}}
\newcommand{\nopi}{\symbol{NopI}}
\newcommand{\returnreli}{\symbol{ReturnRelI}}
\newcommand{\returnfunci}{\symbol{ReturnFuncI}}
\newcommand{\executei}{\symbol{ExecuteI}}
\newcommand{\executeseqi}{\symbol{ExecuteSeqI}}
\newcommand{\calli}{\symbol{CallI}}
\newcommand{\replacei}{\symbol{ReplaceI}}

% Expression
\newcommand{\vare}{\symbol{VarE}}
\newcommand{\nume}{\symbol{NumE}}
\newcommand{\boole}{\symbol{BoolE}}
\newcommand{\fnamee}{\symbol{FnameE}}
\newcommand{\une}{\symbol{UnE}}
\newcommand{\bine}{\symbol{BinE}}
\newcommand{\acce}{\symbol{AccE}}
\newcommand{\upde}{\symbol{UpdE}}
\newcommand{\stre}{\symbol{StrE}}
\newcommand{\compe}{\symbol{CompE}}
\newcommand{\cate}{\symbol{CatE}}
\newcommand{\meme}{\symbol{MemE}}
\newcommand{\lene}{\symbol{LenE}}
\newcommand{\tupe}{\symbol{TupE}}
\newcommand{\casee}{\symbol{CaseE}}
\newcommand{\itere}{\symbol{IterE}}
\newcommand{\liste}{\symbol{ListE}}
\newcommand{\getcurctxe}{\symbol{GetCurContextE}}
\newcommand{\choosee}{\symbol{ChooseE}}
\newcommand{\iscaseofe}{\symbol{IsCaseOfE}}
\newcommand{\ctxkinde}{\symbol{CtxKindE}}
\newcommand{\matche}{\symbol{MatchE}}
\newcommand{\hastypee}{\symbol{HasTypeE}}

% Unary operator
\newcommand{\notop}{\symbol{NotOp}}
\newcommand{\minusop}{\symbol{MinusOp}}

% Binary operator
\newcommand{\addop}{\symbol{AddOp}}
\newcommand{\subop}{\symbol{SubOp}}
\newcommand{\mulop}{\symbol{MulOp}}
\newcommand{\divop}{\symbol{DivOp}}
\newcommand{\modop}{\symbol{ModOp}}
\newcommand{\expop}{\symbol{ExpOp}}
\newcommand{\implop}{\symbol{ImplOp}}
\newcommand{\equivop}{\symbol{EquivOp}}
\newcommand{\andop}{\symbol{AndOp}}
\newcommand{\orop}{\symbol{OrOp}}
\newcommand{\eqop}{\symbol{EqOp}}
\newcommand{\neop}{\symbol{NeOp}}
\newcommand{\ltop}{\symbol{LtOp}}
\newcommand{\gtop}{\symbol{GtOp}}
\newcommand{\leop}{\symbol{LeOp}}
\newcommand{\geop}{\symbol{GeOp}}

% Path
\newcommand{\idxp}{\symbol{Idx}}
\newcommand{\slicep}{\symbol{Slice}}
\newcommand{\dotp}{\symbol{Dot}}

% Iter
\newcommand{\listiter}{\symbol{List}}
\newcommand{\listniter}{\symbol{ListN}}
\newcommand{\listidxiter}{\symbol{Index}}

% Value
\newcommand{\numv}{\symbol{NumV}}
\newcommand{\boolv}{\symbol{BoolV}}
\newcommand{\listv}{\symbol{ListV}}
\newcommand{\strv}{\symbol{StrV}}
\newcommand{\casev}{\symbol{CaseV}}
\newcommand{\tupv}{\symbol{TupV}}
\newcommand{\fnamev}{\symbol{FnameV}}
\newcommand{\trapv}{\symbol{TrapV}}
\newcommand{\storev}{\symbol{StoreV}}




% Helper function
\newcommand{\domain}{\helper{domain}}
\newcommand{\getalgoname}{\helper{get\_algo\_name}}
\newcommand{\lookup}{\helper{lookup}}
\newcommand{\createalgo}{\helper{create\_algo}}
\newcommand{\execute}{\helper{execute}}
\newcommand{\exit}{\helper{exit}}
\newcommand{\duplicateenv}{\helper{duplicate\_env}}
\newcommand{\getenv}{\helper{get\_env}}
\newcommand{\setenv}{\helper{set\_env}}
\newcommand{\getctx}{\helper{get\_ctx}}
\newcommand{\addctx}{\helper{add\_ctx}}
\newcommand{\resetctx}{\helper{reset\_ctx}}
\newcommand{\getstore}{\helper{get\_store}}
\newcommand{\setstore}{\helper{set\_store}}
\newcommand{\prependinstr}{\helper{prepend\_instr}}
\newcommand{\popwasminstr}{\helper{pop\_wasm\_instr}}
\newcommand{\push}{\helper{push}}
\newcommand{\pop}{\helper{pop}}
\newcommand{\popn}{\helper{popn}}
\newcommand{\unop}{\helper{unop}}
\newcommand{\splitctx}{\helper{split\_ctx}}
\newcommand{\getcurctx}{\helper{get\_cur\_ctx}}
\newcommand{\getcurframe}{\helper{get\_cur\_frame}}
\newcommand{\setcurframe}{\helper{set\_cur\_frame}}
\newcommand{\access}{\helper{access}}
\newcommand{\update}{\helper{update}}
\newcommand{\updateidx}{\helper{update\_idx}}
\newcommand{\updateslice}{\helper{update\_slice}}
\newcommand{\updatedot}{\helper{update\_dot}}
\newcommand{\getendinstr}{\helper{get\_end\_instr}}
\newcommand{\istrue}{\helper{is\_true}}
\newcommand{\isframe}{\helper{is\_frame}}
\newcommand{\isctx}{\helper{is\_ctx}}
\newcommand{\zip}{\helper{zip}}
\newcommand{\fold}{\helper{fold}}
% Hardcode
\newcommand{\assign}{\helper{assign}}
\newcommand{\binop}{\helper{binop}}
% Reference interpreter
\newcommand{\match}{\helper{match}}
\newcommand{\hastype}{\helper{has\_type}}




%% Syntax
\section{Syntax of AL}
\label{syntax}

\begin{align*}
\begin{array}{lcccrlr}
%
% State
  \text{State}\quad& \Sigma &\ni& \sigma & ::=& \seq a, w, k \\
%
% Algorithm
  \text{Algorithm}\quad& A &\ni& a &::=& ~ \rel ~ (s, \seq e, \seq i) &\quad\text{(Relation)} \\
  &&&& | & ~ \fun ~ (s, \seq e, \seq i) &\quad\text{(Function)} \\
%
% Wasm state
  \text{Wasm State}\quad& W &\ni& w &::=& \seq{wv}, \seq{wi}, sto \\
  \text{Wasm Value}\quad& WV &\ni& wv &::=& v \\
  \text{Wasm Instruction}\quad& WI &\ni& wi &::=& v \\
%
% Store
  \text{Store}\quad& Store &\ni& sto &::=& \seq{(s, v)} \\
%
% Continuation
  \text{Continuation}\quad & K &\ni& k &::=& ~ \mt &\quad\text{(Empty)} \\
    &&&& | & ~ \toplevelcall ~ (s, \seq v) &\quad\text{(Top-level Call)} \\
    &&&& | & ~ \call ~ (s, s, \seq v, k) &\quad\text{(Call)} \\
    &&&& | & ~ \exe ~ (wi, k) &\quad\text{(Execute)} \\
    &&&& | & ~ \wasm ~ (\seq c, k) &\quad\text{(Wasm)} \\
    &&&& | & ~ \algo ~ (\seq i, \mu, \seq c, k) &\quad\text{(Algorithm)} \\
    &&&& | & ~ \ret ~ (v, k) &\quad\text{(Return)} \\
%
% Environment
  \text{Environment}\quad& M &\ni& \mu &::=& \seq{[s \mapsto v]} \\
%
% Context
  \text{Context}\quad& C &\ni& c &::=& v \\
%
% Instruction
  \text{Instruction}\quad& I &\ni& i &::=& ~ \ifi ~ (e, \seq i, \seq i) &\quad\text{(If)} \\
    &&&& | & ~ \eitheri ~ (\seq i, \seq i) &\quad\text{(Either)} \\
    &&&& | & ~ \enteri ~ (e, e) &\quad\text{(Enter)} \\
    &&&& | & ~ \pushctxi ~ e &\quad\text{(Push Context)} \\
    &&&& | & ~ \pushi ~ e &\quad\text{(Push)} \\
    &&&& | & ~ \popctxi ~ e &\quad\text{(Pop Context)} \\
    &&&& | & ~ \popi ~ e &\quad\text{(Pop)} \\
    &&&& | & ~ \popni ~ (e, e) &\quad\text{(Pop N)} \\
    &&&& | & ~ \popalli ~ e &\quad\text{(Pop All)} \\
    &&&& | & ~ \leti ~ (e, e) &\quad\text{(Let)} \\
    &&&& | & ~ \trapi &\quad\text{(Trap)} \\
    &&&& | & ~ \returnreli &\quad\text{(Return Relation)} \\
    &&&& | & ~ \returnfunci ~ e &\quad\text{(Return Function)} \\
    &&&& | & ~ \executei ~ e &\quad\text{(Execute)} \\
    &&&& | & ~ \executeseqi ~ e &\quad\text{(Execute Sequence)} \\
    &&&& | & ~ \calli ~ (s, s, \seq{e}) &\quad\text{(Let Call)} \\
    &&&& | & ~ \replacei ~ (e, \seq{p}, e) &\quad\text{(Replace)} \\
\end{array}
\end{align*}
\newpage
\begin{align*}
\begin{array}{lcccrlr}
%
% Expression
  \text{Expression}\quad& E &\ni& e &::=& ~ \vare ~ s &\quad\text{(Variable)} \\
    &&&& | & ~ \nume ~ n &\quad\text{(Number)} \\
    &&&& | & ~ \boole ~ b &\quad\text{(Boolean)} \\
    &&&& | & ~ \fnamee ~ s &\quad\text{(Function Name)} \\
    &&&& | & ~ \liste ~ \seq e &\quad\text{(List)} \\
    &&&& | & ~ \stre ~ \seq{(s, e)} &\quad\text{(Record)} \\
    &&&& | & ~ \tupe ~ \seq e &\quad\text{(Tuple)} \\
    &&&& | & ~ \casee ~ (s, \seq e) &\quad\text{(Tagged Tuple)} \\
    &&&& | & ~ \une ~ (unop, e) &\quad\text{(Unary Operation)} \\
    &&&& | & ~ \bine ~ (binop, e, e) &\quad\text{(Binary Operation)} \\
    &&&& | & ~ \acce ~ (e, p) &\quad\text{(Access)} \\
    &&&& | & ~ \upde ~ (e, \seq{p}, e) &\quad\text{(Update)} \\
    &&&& | & ~ \cate ~ (e, e) &\quad\text{(Concatenation)} \\
    &&&& | & ~ \compe ~ (e, e) &\quad\text{(Composition)} \\
    &&&& | & ~ \meme ~ (e, e) &\quad\text{(Membership)} \\
    &&&& | & ~ \choosee ~ e &\quad\text{(Choose)} \\
    &&&& | & ~ \lene ~ e &\quad\text{(Length)} \\
    &&&& | & ~ \iscaseofe ~ (e, s) &\quad\text{(Check Tag)} \\
    &&&& | & ~ \getcurctxe ~ s &\quad\text{(Get Current Context)} \\
    &&&& | & ~ \ctxkinde ~ s &\quad\text{(Context Kind)} \\
    &&&& | & ~ \itere ~ (e, iter, \seq{s}) &\quad\text{(Iteration)} \\
    &&&& | & ~ \matche ~ (e, e) &\quad\text{(Match)} \\
    &&&& | & ~ \hastypee ~ (e, s) &\quad\text{(Has Type)} \\
%
% Operator
  \text{Unary Operator}\quad& Unop &\ni& unop &::=& ~ \notop ~ | ~ \minusop \\
  \text{Binary Operator}\quad& Binop &\ni& binop &::=& ~ \addop &\quad\text{(Addition)} \\
    &&&& | & ~ \subop &\quad\text{(Subtraction)} \\
    &&&& | & ~ \mulop &\quad\text{(Multiplication)} \\
    &&&& | & ~ \divop &\quad\text{(Division)} \\
    &&&& | & ~ \modop &\quad\text{(Modular)} \\
    &&&& | & ~ \expop &\quad\text{(Exponential)} \\
    &&&& | & ~ \implop &\quad\text{(Implication)} \\
    &&&& | & ~ \equivop &\quad\text{(Equivalence)} \\
    &&&& | & ~ \andop &\quad\text{(And)} \\
    &&&& | & ~ \orop &\quad\text{(Or)} \\
    &&&& | & ~ \eqop &\quad\text{(Equal)} \\
    &&&& | & ~ \neop &\quad\text{(Not Equal)} \\
    &&&& | & ~ \ltop &\quad\text{(Less Than)} \\
    &&&& | & ~ \gtop &\quad\text{(Greater Than)} \\
    &&&& | & ~ \leop &\quad\text{(Less or Equal)} \\
    &&&& | & ~ \geop &\quad\text{(Greater or Equal)} \\
\end{array}
\end{align*}
\newpage
\begin{align*}
\begin{array}{lcccrlr}
%
% Path
  \text{Path}\quad& P &\ni& p &::=& ~ \idxp ~ e ~ | ~ \slicep ~ (e, e) ~ | ~ \dotp ~ s \\
%
% Iter
  \text{Iter}\quad& Iter &\ni& iter &::=& ~ \listiter ~ | ~ \listniter ~ e ~|~ \listidxiter ~ (s, e) \\
%
% Value
  \text{Value}\quad& V &\ni& v &::=& ~ \numv ~ n &\quad\text{(Number)} \\
    &&&& | & ~ \boolv ~ b &\quad\text{(Boolean)} \\
    &&&& | & ~ \fnamev ~ s &\quad\text{(Function Name)} \\
    &&&& | & ~ \listv ~ \seq v &\quad\text{(List)} \\
    &&&& | & ~ \strv ~ \seq{(s, v)} &\quad\text{(Record)} \\
    &&&& | & ~ \tupv ~ \seq v &\quad\text{(Tuple)} \\
    &&&& | & ~ \casev ~ (s, \seq v) &\quad\text{(Tagged Tuple)} \\
    &&&& | & ~ \trapv &\quad\text{(Trap)} \\
    &&&& | & ~ \storev &\quad\text{(Store)} \\
% Primitives
  \text{String}\quad& \mathbb S &\ni& s \\
  \text{Integer}\quad& \mathbb Z &\ni& n \\
  \text{Boolean}\quad& \mathbb B &\ni& b \\
\end{array}
\end{align*}

% state
An AL state consists of a sequence of algorithms, a Wasm state, and a
continuation.
% algorithm
An algorithm is either a relation or a function, corresponding to the relation
and the function definitions in the DSL.
% Wasm state
A Wasm state consists of a Wasm value stack, an Wasm instruction stack, and a
store.
% Wasm value & instruction
A Wasm value and instruction are expressed as AL values, particularly in the
form of $\casev$.
% store
A store is expressed as a sequence of field name and AL value pairs.
% continuation
A continuation is \mt{} for an empty continuation, \call{} for a function call
with let binding, \exe{} for executing a given Wasm instruction $wi$, \wasm{}
for executing a Wasm instruction in the instruction stack, \algo{} for
interpreting AL instructions in a algorithm, or \ret{} for returning from an AL
function.
% env
An environment is a finite mapping from a variable name to an AL value.
% context
A context is an AL value, particularyly in the form of \casev{}.
% instruction
An instruction is \ifi{} for conditionally choosing a branch, \eitheri{} for
nondeterministically choosing a branch, \enteri{} for entering a block,
\pushctxi{} for pushing a context, \pushi{} for pushing a Wasm value,
\popctxi{} for popping a context, \popi{} for popping a Wasm value, \popni{}
for popping $n$ Wasm values, \popalli{} for popping all Wasm values within a
context, \leti{} for let binding, \trapi{} for trapping, \returnreli{} for
returning an AL relation, \returnfunci{} for returning an AL function,
\executei{} for executing a Wasm instruction, \executeseqi{} for executing a
Wasm instruction sequence, \calli{} for an AL function call with let binding,
or \replacei{} for replacing some mutable data structure.
% expression
An expression is variable, number, boolean, function name, list, record (or
struct), tuple, tagged tuple, unary operation, binary operation, access to
elements of a data structure, update of elements in a data structure, list
concatenation, record composition, membership checking, choosing an element from
a data structure, getting length, tag checking, getting current context,
checking context kind, iteration, match relation, or type relation.
% value
A value is number, boolean, function name, list, record, tuple, tagged tuple,
trap, or store.


% terminology
State, value, function, and instruction exist in both Wasm and AL. In this
section, we abbreviate AL-specific terms (AL state, AL value, AL function and
AL instruction) as simply state, value, function, and instruction, while
keeping the Wasm terms unchanged.




%% Syntax
\section{Semantics of AL}
\label{semantics}

%% Continuation

\begin{gather*}
\leadsto \subseteq \Sigma \times \Sigma \\
%
% TopLevelCall
\newline \\
  \\
  \hline
  (\seq{a}, w, \toplevelcall ~ (s, \seq v)) \leadsto (\seq{a}, w, \createalgo(\seq a, s, \seq v, \mt)) \\
%
% Call
\newline \\
  \\
  \hline
  (\seq{a}, w, \call ~ (s_{var}, s_{name}, \seq v, k)) \leadsto
  (\seq{a}, w, \createalgo(\seq a, s_{name}, \seq v, \call ~ (s_{var}, s_{name}, \seq v, k))) \\
%
% Execute
\newline \\
  \casev ~ (s, \seq v) = wi \\
  \hline
  (\seq{a}, w, \exe ~ (wi, k)) \leadsto (\seq{a}, w, \createalgo(\seq a, s, \seq v, \mt)) \\
%
% Wasm-empty
\newline \\
  \seq c = \epsilon \\
  \hline
  (\seq{a}, w, \wasm ~ (\seq c, k)) \leadsto (\seq{a}, w, k) \\
%
% Wasm-instr
\newline \\
  \seq c \not= \epsilon \qquad
  (w', \casev ~ (s, \seq v)) = \popwasminstr(w) \\
  \hline
  (\seq{a}, w, \wasm ~ (\seq c, k))
  \leadsto
  (\seq{a}, w', \createalgo(\seq a, s, \seq v, \wasm ~ (\seq c, k))) \\
%
% Al-empty
\newline \\
  \seq i = \epsilon \\
  \hline
  (\seq{a}, w, \algo ~ (\seq i, \mu, \seq c, k)) \leadsto (\seq{a}, w, k) \\
%
% Al-instr
\newline \\
  \seq i = i_0 ~ \seq{i_1} \qquad \seq{a}, w, \algo ~ (\seq{i_1}, \mu, \seq c, k) \vdash i_0 \Rightarrow (w', k') \\
  \hline
  (\seq{a}, w, \algo ~ (\seq i, \mu, \seq c, k)) \leadsto (\seq{a}, w', k') \\
%
% Return
\newline \\
  \mu = \getenv(k) \qquad k' = \setenv(k, \mu[s_0 \mapsto v]) \\
  \hline
  (\seq{a}, w, \ret ~ (v, \call ~ (s_0, s_1, \seq v, k)) \leadsto (\seq a, w, k') \\
\end{gather*}

The semantics of AL is defined by a state transition system.
% TopLevelCall
Given the algorithms $\seq a$ generated from the DSL and the Wasm state $w$, a
top-level function $str$ can be invoked with arguments $\seq v$ to perform
either module instantiation or function invocation:
$(\seq a, w, \toplevelcall ~ (str, \seq v))$.
\toplevelcall{} changes to \algo{} with the function body instructions and
\mt{} continuation nested within it.
% Empty
Here, \mt{} is an empty continuation, representing the end of the transition,
so no further transition occurs.
% Call
Similarly to \toplevelcall{}, \call{} changes to \algo{}, but with the current
continuation nested within it.
% Execute
\exe{} executes a given Wasm instruction $wi$.
The execution involves looking up the corresponding relation definition and
changing the continuation to \algo{} with the body of that relation.
% Wasm
In \wasm{} continuation, a Wasm instruction is popped from the Wasm
instruction stack and executed until the context sequence $\seq c$ is
exhausted.
This execution changes the continuation to \algo{}, with current continuation
nested within it.
% Algo
In \algo{} continuation, the body instructions are executed sequentially.
During execution, the continuation can change to \call{}, \exe{}, \wasm{},
or \ret{}.
The semantics of each instruction will be detailed separately.
% Return
The execution of a function call concludes with a return instruction, changing
the continuation to \ret{} with a return value $v$.
If the function call originates from \call{}, the result is assigned to a
variable.
If it originates from \toplevelcall{}, the inner continuation $k$ is always
\mt, so the entire execution completes with a return value $v'$:
$
(\seq a, w, \toplevelcall ~ (s, \seq v))
\leadsto^*
(\seq a, w', \ret ~ (v', \mt))
$.




%% Instruction

\begin{gather*}
  \text{NOTE: input cont is always \algo} \\
  \seq{a}, ~ w, ~ k \vdash i \Rightarrow w, ~ k \\
%
% If-true
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \qquad
  \istrue(v) \qquad k' = \prependinstr(k, \seq{i_1}) \\
  \hline
  \seq{a}, w, k \vdash \ifi ~ (e, \seq{i_1}, \seq{i_2}) \Rightarrow (w, k') \\
%
% If-false
\newline \\
  \qquad w, \getenv(k) \vdash e \Rightarrow v \qquad
  \neg \istrue(v) \qquad k' = \prependinstr(k, \seq{i_2}) \\
  \hline
  \seq{a}, w, k \vdash \ifi ~ (e, \seq{i_1}, \seq{i_2}) \Rightarrow (w, k') \\
%
% Either-1
\newline \\
  \\
  \hline
  \seq{a}, w, k \vdash \eitheri ~ (\seq{i_1}, \seq{i_2}) \Rightarrow (w, \prependinstr(k, \seq{i_1})) \\
%
% Either-2
\newline \\
  \\
  \hline
  \seq{a}, w, k \vdash \eitheri ~ (\seq{i_1}, \seq{i_2}) \Rightarrow (w, \prependinstr(k, \seq{i_2})) \\
%
% Enter
\newline \\
  (\seq{wv}, \seq{wi}, sto) = w \qquad
  \mu = \getenv(k) \qquad
  \seq c = \getctx(k) \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad
  w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \qquad
  \seq{wi_{end}} = [ ~ \getendinstr(c) ~ | ~ c \leftarrow v_1 ~ \seq c ~ ] \\
  \hline
  \seq{a}, w, k \vdash \enteri ~ (e_1, e_2)
  \Rightarrow
  ((v_1 ~ \seq{wv}, \seq{v_2} ~ \seq{wi_{end}}~ \seq{wi}, sto), \wasm ~ (v_1 ~ \seq c, \resetctx(k))) \\
%
% PushCtx
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \pushctxi ~ e
  \Rightarrow
  (\push(w, v), \addctx(k, v)) \\
%
% Push
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \pushi ~ e \Rightarrow (\push(w, v), k) \\
%
% PopCtx
\newline \\
  wv_{ctx} ~ \seq{wv'} = \exit_{WasmValue}(\seq{wv}) \qquad
  \mu = \assign(\getenv(k), e, wv_{ctx}) \\
  \seq{wi'} = \exit_{WasmInstr}(\seq{wi}) \qquad
  k_1 = \exit_{K}(k) \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), k \vdash \popctxi ~ e
  \Rightarrow
  ((\seq{wv'}, \seq{wi'}, sto), \setenv(k_1, \mu)) \\
%
% Pop
\newline \\
  (w', wv) = \pop(w) \qquad
  \mu' = \assign(\getenv(k), e, wv) \\
  \hline
  \seq{a}, w, k \vdash \popi ~ e \Rightarrow (w', \setenv(k, \mu')) \\
%
% PopN
\newline \\
  \mu = \getenv(k) \qquad
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \\
  (w', wv^n) = \popn(w, n) \qquad
  \mu' = \assign(\mu, e_1, \listv ~ wv^n) \\
  \hline
  \seq{a}, w, k \vdash \popni ~ (e_1, e_2) \Rightarrow (w', \setenv(k, \mu')) \\
%
% PopAll
\newline \\
  (\seq{wv_0}, \seq{wv_1}) = \splitctx(wv) \qquad
  \mu' = \assign(\getenv(k), e, \listv ~ \seq{wv_0}) \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), e \vdash \popalli ~ e
  \Rightarrow
  ((\seq{wv_1}, \seq{wi}, sto), \setenv(k, \mu')) \\
%
% Let
\newline \\
  \mu = \getenv(k) \qquad
  w, \mu \vdash e_2 \Rightarrow v \qquad
  \mu' = \assign(\mu, e_1, v) \\
  \hline
  \seq{a}, w, k \vdash \leti ~ (e_1, e_2)
  \Rightarrow
  (w, \setenv(k, \mu')) \\
%
% Trap
\newline \\
  \\
  \hline
  \seq{a}, w, k \vdash \trapi \Rightarrow (w, \ret ~ (\trapv, \mt)) \\
%
% Return-rule
\newline \\
  \\
  \hline
  \seq{a}, w, \algo~ (\seq{i}, \mu, \seq c, k) \vdash \returnreli \Rightarrow (w, k) \\
%
% Return-func
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, \algo ~ (\seq{i}, \mu, \seq c, k) \vdash \returnfunci ~ e \Rightarrow (w, \ret ~ (v, k)) \\
%
% Execute
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \executei ~ e \Rightarrow (w, \exe ~ (v, k)) \\
%
% ExecuteSeq
\newline \\
  w, \getenv(k) \vdash e \Rightarrow \listv ~ \seq v \qquad
  k' = \fold(\execute, \seq v, k) \\
  \hline
  \seq{a}, w, k \vdash \executeseqi ~ e \Rightarrow (w, k') \\
%
% Call-fname
\newline \\
  \mu = \getenv(k) \qquad
  \fnamev ~ s_2 = \mu(s_1) \qquad
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  \seq{a}, w, k \vdash \calli ~ (s_0, s_1, \seq e) \Rightarrow (w, \call ~ (s_0, s_2, \seq v, k)) \\
%
% Call-fname
\newline \\
  \mu = \getenv(k) \qquad
  s_1 \not\in \domain(\mu) \qquad
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  \seq{a}, w, k \vdash \calli ~ (s_0, s_1, \seq e) \Rightarrow (w, \call ~ (s_0, s_1, \seq v, k)) \\
%
% Replace-frame
\newline \\
\text{NOTE: $e_1$ is either store or current frame} \\
  \mu = \getenv(k) \qquad
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad
  \isframe(v_1) \qquad
  w, \mu \vdash e_2 \Rightarrow v_2 \qquad
  v_3 = \update(w, \mu, v_1, \seq p, v_2) \\
  \hline
  \seq{a}, w, k \vdash \replacei ~ (e_1, \seq{p}, e_2) \Rightarrow (\setcurframe(w, v_3), k) \\
%
% Replace-store
\newline \\
  \mu = \getenv(k) \qquad
  w, \mu \vdash e_1 \Rightarrow \storev \qquad
  w, \mu \vdash e_2 \Rightarrow v_2 \\
  sto = \update(w, \mu, \strv (\getstore(w)), \seq p, v_2) \\
  \hline
  \seq{a}, w, k \vdash \replacei ~ (e_1, \seq{p}, e_2)
  \Rightarrow (\setstore(w, sto), k) \\
\end{gather*}

Given the algorithms $\seq a$, Wasm state $w$, and continuation, executing an
instruction produces an updated Wasm state and a new continuation.
Here, the input continuation is always \algo{}, but instead of enumerating all
arguments individually, we encapsulate them within the \algo{} continuation.
% If
\ifi{} instruction evaluates a $e$ and selects the corresponding branch.
% Either
\eitheri{} instruction nondeterministically selects a branch.
% Enter
\enteri{} instruction is a key instruction to describe Wasm control flow.
It evaluates $e_1$ and pushes the context $v_1$ to the Wasm value stack.
It also evaluates $e_2$ to get Wasm instruction sequence $\seq{v_2}$.
Then, it appends end instruction of pushed contexts including $v_1$, and pushes
them to the Wasm instruction stack.
Finally, it resets the contexts of the continuation.
% PushCtx
\pushctxi{} instruction evaluates $e$, pushes the context and add the context
in the continuation.
% Push
\pushi{} instruction evaluates $e$ and pushes the value to the Wasm value
stack.
% PopCtx
\popctxi{} instruction is another key instruction to describe Wasm control
flow.
It pops all the Wasm value until context inclusively and the Wasm instructions
until end instruction inclusively.
It also pops the context in the continuation.
Then, it assign the context to $e$.
% Pop
\popi{} instruction pops a Wasm value and assign the value to $e$.
% PopN
\popn{} instruction evalutes $e_2$ to get n and pops n Wasm values and assign
the values to $e_1$.
% PopAll
\popalli{} instruction pops all the Wasm value until context exclusively and
assign the values to $e_1$.
% Let
\leti{} instruction evaluates $e_2$ and assign the value to $e_1$.
% Trap
\trapi{} instruction terminates the execution with \trapv{}.
% ReturnRel
\returnreli{} instruction pops a continuation.
% ReturnFunc
\returnfunci{} instruction evaluates $e$, pops a continuation, and results in
\ret{} with the resulting value.
% Execute
\executei{} instruction evaluates $e$ and result in a \exe{} with the value.
% Execute Sequence
\executeseqi{} instruction evaluates $e$ and result in a nesting \exe{}.
% Call
\calli{} instruction checks the environment and if $s_1$ exists, gets the
function name in the environment, and if not, uses $s_1$ as the function name.
It evaluates $\seq e$ and construct \call{} with binding variable, the function
name, and the values.
\replacei{} evaluates $e_1$ and $e_2$ to $v_1$ and $v_2$.
If $v_1$ is frame, access the frame with $p$ and update the value to $v_2$.
If $v_1$ is store, access the store with $p$ and update the value to $v_2$.




%% Expression

\begin{gather*}
  w, \mu \vdash e \Rightarrow v \\
%
% Var
\newline \\
  v = \mu(s) \\
  \hline
  w, \mu \vdash \vare ~ s \Rightarrow v \\
%
% Num
\newline \\
  \hline
  w, \mu \vdash \nume ~ n \Rightarrow \numv ~ n \\
%
% Bool
\newline \\
  \hline
  w, \mu \vdash \boole ~ b \Rightarrow \boolv ~ b \\
%
% Fname
\newline \\
  \hline
  w, \mu \vdash \fnamee ~ s \Rightarrow \fnamev ~ s \\
%
% List
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \liste ~ \seq{e} \Rightarrow \listv ~ \seq{v} \\
%
% Str
\newline \\
  \seq{(s, v)} =
    [ ~
      s, v
    ~ | ~
      (s, e) \leftarrow \seq{(s, e)}; ~ w, \mu \vdash e \Rightarrow v
    ~ ] \\
  \hline
  w, \mu \vdash \stre ~ \seq{(s, e)} \Rightarrow \strv ~ \seq{(s, v)} \\
%
% Tup
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \tupe ~ \seq{e} \Rightarrow \tupv ~ \seq{v} \\
%
% Case
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \casee ~ (s, \seq{e}) \Rightarrow \casev ~ (s, \seq{v}) \\
%
% Un
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \une ~ (unop, e) \Rightarrow \unop(unop, v) \\
%
% Bin
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \bine ~ (binop, e_1, e_2) \Rightarrow \binop(binop, v_1, v_2) \\
%
% Acc
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \acce ~ (e, p) \Rightarrow \access(w, \mu, v, p) \\
%
% Upd
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \upde ~ (e_1, \seq p, e_2) \Rightarrow \update(w, \mu, v_1, \seq p, v_2) \\
%
% Cat
\newline \\
   w, \mu \vdash e_1 \Rightarrow \listv ~ \seq{v_1} \qquad
   w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \hline
  w, \mu \vdash \cate ~ (e_1, e_2) \Rightarrow \listv ~ (\seq{v_1} ~ \seq{v_1}) \\
%
% Comp
\newline \\
   w, \mu \vdash e_1 \Rightarrow \strv ~ \seq{(s_1, v_1)} \qquad
   w, \mu \vdash e_2 \Rightarrow \strv ~ \seq{(s_2, v_2)} \\
  \hline
  w, \mu \vdash \compe ~ (e_1, e_2) \Rightarrow \strv ~ (\seq{(s_1, v_1)} ~ \seq{(s_2, v_2)}) \\
%
% Mem
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad
  w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \hline
  w, \mu \vdash \meme ~ (e_1, e_2) \Rightarrow \boolv ~ (v_1 \in \seq{v_2}) \\
%
% Choose
\newline \\
  w, \mu \vdash e \Rightarrow \listv ~ \seq{v} \qquad
  v \in \seq{v} \\
  \hline
  w, \mu \vdash \choosee ~ e \Rightarrow v \\
%
% Len
\newline \\
  w, \mu \vdash e \Rightarrow \listv ~ \seq{v} \\
  \hline
  w, \mu \vdash \lene ~ e \Rightarrow \numv ~ |\seq v| \\
%
% IsCaseOf
\newline \\
  w, \mu \vdash e \Rightarrow \casev ~ (s', \seq{v}) \\
  \hline
  w, \mu \vdash \iscaseofe ~ (e, s) \Rightarrow \boolv ~ (s = s') \\
%
% GetCurCtx
\newline \\
  v_{ctx} = \getcurctx(w, s) \\
  \hline
  w, \mu \vdash \getcurctxe ~ s \Rightarrow v_{ctx} \\
%
% CtxKind
\newline \\
  \casev (s', \seq v) = \getcurctx(w, s) \\
  \hline
  w, \mu \vdash \ctxkinde ~ s \Rightarrow \boolv ~ (s = s') \\
%
% Iter-
\newline \\
  f =
    (\lambda ~ s ~ acc. ~
      \listv ~ \seq v = \mu(s); ~
      [ ~ \mu_1[s \mapsto v] ~ | ~ (v, \mu_1) \leftarrow \zip (\seq v, acc) ~ ]
    )
  \\
  \seq{\mu_2} = \fold(f, \seq{s}, \duplicateenv(\mu, \seq{s})) \qquad
  \seq{v_1} =
    [ ~
      v_1
    ~ | ~
      \mu_3 \leftarrow \seq {\mu_2}; ~ w, \mu_3 \vdash e_1 \Rightarrow v_1
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listiter, \seq{s}) \Rightarrow \listv ~ \seq{v_1} \\
%
% Iter-n
\newline \\
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \\
  f_i =
    (\lambda ~ x ~ acc. ~
      \listv ~ \seq v = \mu(x); ~
      [ ~ \mu_1[s \mapsto v] ~ | ~ (v, \mu_1) \leftarrow \zip (\seq v, acc) ~ ]
    )
  \\
  \seq{\mu_2} = \fold(f, \seq{s}, \mu^n) \qquad
  \seq{v'} =
    [ ~
      v'
    ~ | ~
      \mu_3 \leftarrow \seq {\mu_2}; ~ w, \mu_3 \vdash e_1 \Rightarrow v'
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listniter ~ e_2, \seq{s}) \Rightarrow \listv ~ \seq{v'} \\
%
% Iter-idx
\newline \\
  w, \mu \vdash e_2 \Rightarrow \listv ~ n \qquad
  \seq{\mu_1} =
    [ ~
      \fold(
        (\lambda ~ x ~ acc. ~ acc[x \mapsto \numv ~ i]),
        \seq{s},
        \mu
      )
    ~ | ~
      i \leftarrow [0 ~ .. ~ n-1]
    ~ ]
  \\
  \seq{v'} =
    [ ~
      v'
    ~ | ~
      \mu_2 \leftarrow \seq {\mu_1}; ~ w, \mu_2 \vdash e_1 \Rightarrow v'
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listidxiter ~ e_2, \seq{s}) \Rightarrow \listv ~ \seq{v'} \\
%
% Match
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad
  w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \matche ~ (e_1, e_2) \Rightarrow \boolv ~ (\match(v_1, v_2)) \\
%
% HasType
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \hastypee ~ (e, s) \Rightarrow \boolv ~ (\hastype(v, s)) \\
\end{gather*}

Given Wasm state $w$, and an environment $\mu$, an expression evaluates to a
value.
% Var
\vare{} expression looks up the environment and gets the value.
% Num Bool Fname
\nume{}, \boole{}, and \fnamee{} expressions directly reduce to \numv{},
\boolv{}, and \fnamev{}, respectively.
% Tuple Case List Struct
\liste{}, \stre{}, \tupe{}, and \casee{} expressions evaluate inner expressions
and reduce to \listv{}, \strv{}, \tupv{}, and \casev{}, respectively.
% Un Bin
\une{} and \bine{} expression evaluates inner expressions and perform \unop{}
and \binop{}.
% Acc
\acce{} expression accesses the elements of a data structure.
% Upd
\upde{} expression update a value of a data structure.
% Cat Comp
\cate{} and \compe{} expressions concatenate two lists and records,
respectively.
% Mem
\meme{} expression performs membership check.
% Choose
\choosee{} expression chooses an element of a datastructure.
% Len
\lene{} expression gets a length of a data structure.
% IsCaseOf
\iscaseofe{} expression checks a tag of a tagged tuple.
% GetCurCtx
\getcurctxe{} expression gets the current context.
% CtxKind
\ctxkinde{} expression checks the kind of the current context.
% Iter
\itere{} expression behaves differently depending on $iter$.
\listiter{} and \listniter{} are basically the same.
They assume that the all the values mapped to the variables $\seq s$ by the
envinronment $\mu${} are \listv{} with same length.
\listniter{} restricts the length to $n$ obtained from evaluating $e_2$,
while \listiter{} allows any length.
It generates a sequence of environments where the k-th environment maps each
variables to the k-th elements of the \listv{}.
Each environment is then used to evaluate $e_1$, and the resulting values are
wrapped to \listv{}.
\listidxiter{} behaves similarly except that the variables $\seq s$ are
unbound.
It evaluates $e_2$ to obtain $n$ and then behaves like \listniter{} as if
$\listv ~ [0 ~ ... ~ n-1]$ was bound to the variables.
% IsValid Match HasType
\matche{} and \hastypee{} expressions evaluate inner exressions and perform
\match{} and \hastype{}, respectively.
Note that \match{} and \hastype{} are implementations of Wasm static semantics.
Their formalization is omitted as they are highly specific to Wasm and
excessively verbose.




%% Helper functions

\begin{align*}
%
% domain
\newline \\
  &\domain(\mu) = \{ ~ x ~ | ~ \mu(x) = v ~ \} \\
%
% get_algo_name
\newline \\
  &\getalgoname(\rel ~ (s, \seq e, \seq i)) = s \\
  &\getalgoname(\fun ~ (s, \seq e, \seq i)) = s \\
%
% lookup
\newline \\
  &\lookup(a ~ \seq{a}, s) =
    \begin{cases}
      a &\quad\quad \premise{if}\quad ~ s = \getalgoname(a) \\
      \lookup(\seq{a}, s) &\quad\quad \premise{otherwise}
    \end{cases}
  \\
%
% create_algo
\newline \\
  &\createalgo(\seq a, s, \seq v, k) =
  \algo(\seq i, \mu, \epsilon, k) \\
  &\qquad\qquad\qquad\qquad\premise{if}\quad
  (\rel ~ (s, \seq e, \seq i) \quad\lor\quad \fun ~ (s, \seq e, \seq i)) = \lookup(\seq a, s)
  \quad\land\quad
  \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
%
% split_ctx
\newline \\
&\text{NOTE: an input of is\_ctx (WasmValue sequence) contains at least one context} \\
  &\splitctx(wv ~ \seq{wv}) =
    \begin{cases}
      (\epsilon, wv ~ \seq{wv}) &\quad\quad \premise{if}\quad ~ \isctx(wv) \\
      (wv ~ \seq{wv_0}, \seq{wv_1}) &\quad\quad \premise{if}\quad ~ \neg\isctx(wv) \quad\land\quad (\seq{wv_0}, \seq{wv_1}) = \splitctx(\seq{wv})
    \end{cases}
  \\
%
% execute
\newline \\
  &\execute(v, k) = \exe(v, k) \\
%
% exit_cont-wasm_0
\newline \\
&\text{NOTE: input cont of exit is either \algo ~ or \wasm} \\
  &\exit_{K}(\wasm ~ (\epsilon, k)) = \wasm ~ (\epsilon, \exit_{K}(k)) \\
% exit_cont-wasm_nonzero
  &\exit_{K}(\wasm ~ (c ~ \seq{c}, k)) = \wasm ~ (\seq{c}, k) \\
% exit_cont-al
  &\exit_{K}(\algo ~ (\seq i, \mu, \seq c, k)) = \algo ~ (\seq i, \mu, \seq c, \exit(k)) \\
%
% exit_wasm_instr-end
\newline \\
  &\exit_{WasmInstr}(wi ~ \seq{wi}) =
    \begin{cases}
      \seq{wi} &\quad\quad \premise{if}\quad ~ \helper{is\_end}(wi) \\
      \exit_{WasmInstr}(\seq{wi}) &\quad\quad \premise{otherwise} \\
    \end{cases}
  \\
%
% exit_wasm_value
\newline \\
  &\exit_{WasmValue}(\seq{wv}) = \seq{wv_1}
  \quad\quad\premise{if}\quad ~ (\seq{wv_0}, \seq{wv_1}) = \splitctx(\seq{wv}) \\
%
% duplicate_env-empty
\newline \\
  &\duplicateenv(\mu, epsilon) = \mu \\
% duplicate_env-nonempty
  &\duplicateenv(\mu, s ~ \seq{s}) = \mu^{|\seq v|}
  \quad\quad\premise{if}\quad ~ \listv ~ \seq v = \mu(s) \\
%
% get_env
\newline \\
  &\getenv(\algo ~ (\seq i, \mu, \seq c, k)) = \mu \\
%
% set_env
\newline \\
  &\setenv(\algo ~ (\seq i, \mu, \seq c, k), \mu') = \algo ~ (\seq i, \mu', \seq c, k) \\
%
% prepend_instr
\newline \\
  &\prependinstr(\algo ~ (\seq i, \mu, \seq c, k), \seq{i'}) = \algo ~ (\seq{i'} ~ \seq i, \mu, \seq c, k) \\
%
% get_ctx
\newline \\
  &\getctx(\algo ~ (\seq i, \mu, \seq c, k)) = \seq c \\
%
% add_ctx
\newline \\
  &\addctx(\algo ~ (\seq i, \mu, \seq c, k), c') = \algo ~ (\seq i, \mu, c' ~ \seq c, k) \\
%
% reset_ctx
\newline \\
  &\resetctx(\algo ~ (\seq i, \mu, \seq c, k)) = \algo ~ (\seq i, \mu, \epsilon, k) \\
%
% get_store
\newline \\
  &\getstore((\seq{wv}, \seq{wi}, sto)) = sto \\
%
% set_store
\newline \\
  &\setstore((\seq{wv}, \seq{wi}, sto), sto') = (\seq{wv}, \seq{wi}, sto') \\
%
% pop_wasm_instr
\newline \\
  &\popwasminstr((\seq{wv}, wi ~ \seq{wi}, sto)) = ((\seq{wv}, \seq{wi}, sto), wi) \\
%
% push
\newline \\
  &\push((\seq{wv}, \seq{wi}, sto), wv) = (wv ~ \seq{wv}, \seq{wi}, sto) \\
%
% pop
\newline \\
  &\pop((wv ~ \seq{wv}, \seq{wi}, sto)) = ((\seq{wv}, \seq{wi}, sto), wv) \\
%
% popn
\newline \\
  &\popn((wv^n ~ \seq{wv}, \seq{wi}, sto), n) = ((\seq{wv}, \seq{wi}, sto), wv^n) \\
%
% unop
\newline \\
  &\unop(\notop, v) =
    \begin{cases}
      \boolv ~ true &\quad\quad\premise{if}\quad ~ \istrue(v) \\
      \boolv ~ false &\quad\quad\premise{otherwise} \\
    \end{cases}
  \\
  &\unop(\minusop, \numv ~ n) = \numv ~ (-n) \\
%
% get_cur_ctx
\newline \\
  &\getcurctx((\seq{wv}, \seq{wi}, sto)) =
  wv_{ctx} \quad\quad\premise{if}\quad ~ (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \\
%
% get_cur_frame-frame
\newline \\
  &\getcurframe((\seq{wv}, \seq{wi}, sto)) =
    \begin{cases}
      wv_{ctx} &\quad\quad\premise{if}\quad
      (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \quad\land\quad \isframe(wv_{ctx})\\
      \getcurframe(\seq{wv_1}) &\quad\quad\premise{if}\quad
      (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \quad\land\quad \neg \isframe(wv_{ctx}) \\
    \end{cases}
  \\
%
% set_cur_frame-frame
\newline \\
  &\setcurframe((\seq{wv}, \seq{wi}, sto), v_{frame})
  =
  \begin{cases}
    (\seq{wv_0} ~ v_{frame} ~ \seq{wv_1}, \seq{wi}, sto) \\
    \qquad\qquad\qquad\quad\premise{if}\quad
    (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \quad \isframe(wv_{ctx}) \\
    (\seq{wv_0} ~ wv_{ctx} ~ \setcurframe(\seq{wv_1}, v_{frame}), \seq{wi}, sto) \\
    \qquad\qquad\qquad\quad\premise{if}\quad
    (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \quad \neg \isframe(wv_{ctx}) \\
  \end{cases}
  \\
%
% access-idx
\newline \\
  &\access(w, \mu, \listv ~ \seq{v}, \idxp ~ e) = \seq{v}[n]
  \qquad\qquad\qquad~\,\quad\premise{if}\quad w, \mu \vdash e \Rightarrow \numv ~ n \\
% access-slice
  &\access(w, \mu, \listv ~ \seq{v}, \slicep ~ (e_1, e_2)) = \seq{v}[n_1: n_2]
  \quad\quad\premise{if}\quad
  w, \mu \vdash e_1 \Rightarrow \numv ~ n_1 \quad\land\quad
  w, \mu \vdash e_2 \Rightarrow \numv ~ n_2 \\
% access-dot
  &\access(w, \mu, \strv ~ ((s_0, v_0) ~ \seq{(s_1, v_1)}), \dotp ~ s) =
  \begin{cases}
    v_0 &\quad\quad\premise{if}\quad s_0 = s \\
    \access(w, \mu, \strv ~ \seq{(s_1, v_1)}, \dotp ~ s) &\quad\quad\premise{otherwise} \\
  \end{cases}
  \\
% access-store
  &\access(w, \mu, \storev, p) =\access(w, \mu, \strv ~ sto, p)
  \quad\quad\premise{if}\quad w = (\seq{wv}, \seq{wi}, sto)\\
%
% update
\newline \\
  % idx
  &\update(w, \mu, \listv ~ \seq{v}, (\idxp ~ e) ~ \seq{p}, v) =
  \listv ~ (\updateidx(\seq v, n, \update(w, \mu, \seq{v}[n], \seq{p}, v))) \\
  &\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\premise{if}\quad
  w, \mu \vdash e \Rightarrow \numv ~ n \\
  % slice
  &\update(w, \mu, \listv ~ \seq{v}, (\slicep ~ e) ~ \seq{p}, v) =
  \listv ~ (\updateslice(\seq v, n_1, n_2, \update(w, \mu, \seq{v_i}[n_1: n_2], \seq{p}, v))) \\
  &\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\premise{if}\quad
  w, \mu \vdash e_1 \Rightarrow \numv ~ n_1 \quad\land\quad
  w, \mu \vdash e_2 \Rightarrow \numv ~ n_2 \\
  % dot
  &\update(w, \mu, \strv ~ \seq{(s, v)}, (\dotp ~ s') ~ \seq{p}, v)
  =
  \strv ~ (\updatedot(\seq{(s, v)}, s', \update(w, \mu, \access(v, \dotp ~ s'), \seq{p}, v))) \\
%
% update_idx
\newline \\
  &\updateidx(v_0 ~ \seq{v_1}, n, v_2) =
  \begin{cases}
    v_2 ~ \seq{v_1}
    &\quad\quad\premise{if}\quad n = 0 \\
    v_0 ~ \updateidx(\seq{v_1}, n-1, v_2)
    &\quad\quad\premise{if}\quad n > 0 \\
  \end{cases} \\
%
% update_slice
\newline \\
  &\updateslice(v_0^n ~ \seq{v_1}, 0, n, v_2^n) = v_2^n ~ \seq{v_1} \\
  &\updateslice(v_0 ~ \seq{v_1}, m, n, v_2^n) =  v_0 ~ \updateslice(\seq{v_1}, m-1, n, v_2)
  \quad\quad\premise{if}\quad m > 0 \\
%
% update_dot
\newline \\
  &\updatedot((s_0, v_0) ~ \seq{(s_1, v_1)}, s_2, v_2) =
  \begin{cases}
    (s_2, v_2) ~ \seq{(s_1, v_1)}
    &\quad\quad\premise{if}\quad s_0 = s_2 \\
    (s_0, v_0) ~ \updatedot(\seq{(s_1, v_1)}, s_2, v_2)
    &\quad\quad\premise{otherwise}
  \end{cases}
  \\
%
% get_end_algo
\newline \\
  &\getendinstr(\casev ~ (\text{"LABEL"}, \seq v)) = \casev ~ (\text{"EXTING"}, \epsilon) \\
  &\getendinstr(\casev ~ (\text{"FRAME"}, \seq v)) = \casev ~ (\text{"RETURNING"}, \epsilon) \\
%
% is_true
\newline \\
  &\istrue(\boolv ~ b) = b \\
  &\istrue(\listv ~ \seq v) = \forall v \in \seq v. \istrue (v) \\
%
% is_frame
\newline \\
  &\isframe(v) =
  \begin{cases}
    true
    &\quad\quad\premise{if}\quad v = \casev ~ (\text{"FRAME"}, \seq v) \\
    false &\quad\quad\premise{otherwise}\\
  \end{cases}
  \\
%
% is_ctx
\newline \\
  &\isctx(v) =
  \begin{cases}
    true
    &\quad\quad\premise{if}\quad v = (\casev ~ (\text{"FRAME"}, \seq v) \quad\lor\quad \casev ~ (\text{"LABEL"}, \seq v)) \\
    false &\quad\quad\premise{otherwise}\\
  \end{cases}
%
% zip
\newline \\
  &\zip(eps, eps) = eps \\
  &\zip(x ~ \seq{x}, y ~ \seq{y}) = (x, y) ~ \zip (\seq{x}, \seq{y}) \\
%
% fold
\newline \\
  &\fold(f, x^n, acc) = f(x_0, f(x_1, ~ ... ~ f(x_{n-2}, f(x_{n-1}, acc)) ~ ... ~ ))
\end{align*}





