% !TEX root = main.tex

\chapter{Formalization}
\label{ch:Formalization}
\noindent



\newcommand{\seq}[1]{#1^*}



%% font definitions

\renewcommand{\symbol}[1]{\textbf{#1}}
\newcommand{\helper}[1]{\textsf{#1}}
\newcommand{\premise}[1]{\textsf{\textbf{#1}}}

% Algorithm
\newcommand{\rel}{\symbol{Rel}}
\newcommand{\fun}{\symbol{Fun}}

% Continuation
\newcommand{\mt}{\symbol{Empty}}
\newcommand{\toplevelcall}{\symbol{TopLevelCall}}
\newcommand{\call}{\symbol{Call}}
\newcommand{\wasm}{\symbol{Wasm}}
\newcommand{\exe}{\symbol{Execute}}
\newcommand{\algo}{\symbol{Algo}}
\newcommand{\ret}{\symbol{Return}}

% Instruction
\newcommand{\ifi}{\symbol{IfI}}
\newcommand{\eitheri}{\symbol{EitherI}}
\newcommand{\enteri}{\symbol{EnterI}}
\newcommand{\pushctxi}{\symbol{PushCtxI}}
\newcommand{\pushi}{\symbol{PushI}}
\newcommand{\popctxi}{\symbol{PopCtxI}}
\newcommand{\popi}{\symbol{PopI}}
\newcommand{\popni}{\symbol{PopNI}}
\newcommand{\popalli}{\symbol{PopAllI}}
\newcommand{\leti}{\symbol{LetI}}
\newcommand{\trapi}{\symbol{TrapI}}
\newcommand{\nopi}{\symbol{NopI}}
\newcommand{\returnreli}{\symbol{ReturnRelI}}
\newcommand{\returnfunci}{\symbol{ReturnFuncI}}
\newcommand{\executei}{\symbol{ExecuteI}}
\newcommand{\calli}{\symbol{CallI}}
\newcommand{\replacei}{\symbol{ReplaceI}}

% Expression
\newcommand{\vare}{\symbol{VarE}}
\newcommand{\nume}{\symbol{NumE}}
\newcommand{\boole}{\symbol{BoolE}}
\newcommand{\fnamee}{\symbol{FnameE}}
\newcommand{\une}{\symbol{UnE}}
\newcommand{\bine}{\symbol{BinE}}
\newcommand{\acce}{\symbol{AccE}}
\newcommand{\upde}{\symbol{UpdE}}
\newcommand{\stre}{\symbol{StrE}}
\newcommand{\compe}{\symbol{CompE}}
\newcommand{\cate}{\symbol{CatE}}
\newcommand{\meme}{\symbol{MemE}}
\newcommand{\lene}{\symbol{LenE}}
\newcommand{\tupe}{\symbol{TupE}}
\newcommand{\casee}{\symbol{CaseE}}
\newcommand{\itere}{\symbol{IterE}}
\newcommand{\liste}{\symbol{ListE}}
\newcommand{\getcurctxe}{\symbol{GetCurContextE}}
\newcommand{\choosee}{\symbol{ChooseE}}
\newcommand{\iscaseofe}{\symbol{IsCaseOfE}}
\newcommand{\ctxkinde}{\symbol{CtxKindE}}
\newcommand{\matche}{\symbol{MatchE}}
\newcommand{\hastypee}{\symbol{HasTypeE}}

% Unary operator
\newcommand{\notop}{\symbol{NotOp}}
\newcommand{\minusop}{\symbol{MinusOp}}

% Binary operator
\newcommand{\addop}{\symbol{AddOp}}
\newcommand{\subop}{\symbol{SubOp}}
\newcommand{\mulop}{\symbol{MulOp}}
\newcommand{\divop}{\symbol{DivOp}}
\newcommand{\modop}{\symbol{ModOp}}
\newcommand{\expop}{\symbol{ExpOp}}
\newcommand{\implop}{\symbol{ImplOp}}
\newcommand{\equivop}{\symbol{EquivOp}}
\newcommand{\andop}{\symbol{AndOp}}
\newcommand{\orop}{\symbol{OrOp}}
\newcommand{\eqop}{\symbol{EqOp}}
\newcommand{\neop}{\symbol{NeOp}}
\newcommand{\ltop}{\symbol{LtOp}}
\newcommand{\gtop}{\symbol{GtOp}}
\newcommand{\leop}{\symbol{LeOp}}
\newcommand{\geop}{\symbol{GeOp}}

% Path
\newcommand{\idxp}{\symbol{Idx}}
\newcommand{\slicep}{\symbol{Slice}}
\newcommand{\dotp}{\symbol{Dot}}

% Iter
\newcommand{\listiter}{\symbol{List}}
\newcommand{\listniter}{\symbol{ListN}}
\newcommand{\listidxiter}{\symbol{Index}}

% Value
\newcommand{\numv}{\symbol{NumV}}
\newcommand{\boolv}{\symbol{BoolV}}
\newcommand{\listv}{\symbol{ListV}}
\newcommand{\strv}{\symbol{StrV}}
\newcommand{\casev}{\symbol{CaseV}}
\newcommand{\tupv}{\symbol{TupV}}
\newcommand{\fnamev}{\symbol{FnameV}}
\newcommand{\trapv}{\symbol{TrapV}}
\newcommand{\storev}{\symbol{StoreV}}




% Helper function
\newcommand{\domain}{\helper{domain}}
\newcommand{\getalgoname}{\helper{get\_algo\_name}}
\newcommand{\lookup}{\helper{lookup}}
\newcommand{\createalgo}{\helper{create\_algo}}
\newcommand{\execute}{\helper{execute}}
\newcommand{\exit}{\helper{exit}}
\newcommand{\getenv}{\helper{get\_env}}
\newcommand{\setenv}{\helper{set\_env}}
\newcommand{\addctx}{\helper{add\_ctx}}
\newcommand{\getstore}{\helper{get\_store}}
\newcommand{\setstore}{\helper{set\_store}}
\newcommand{\prependinstr}{\helper{prepend\_instr}}
\newcommand{\popwasminstr}{\helper{pop\_wasm\_instr}}
\newcommand{\push}{\helper{push}}
\newcommand{\pop}{\helper{pop}}
\newcommand{\popn}{\helper{popn}}
\newcommand{\unop}{\helper{unop}}
\newcommand{\splitctx}{\helper{split\_ctx}}
\newcommand{\getcurctx}{\helper{get\_cur\_ctx}}
\newcommand{\getcurframe}{\helper{get\_cur\_frame}}
\newcommand{\setcurframe}{\helper{set\_cur\_frame}}
\newcommand{\access}{\helper{access}}
\newcommand{\update}{\helper{update}}
\newcommand{\updateidx}{\helper{update\_idx}}
\newcommand{\updateslice}{\helper{update\_slice}}
\newcommand{\updatedot}{\helper{update\_dot}}
\newcommand{\getendinstr}{\helper{get\_end\_instr}}
\newcommand{\isendinstr}{\helper{is\_end\_instr}}
\newcommand{\istrue}{\helper{is\_true}}
\newcommand{\isframe}{\helper{is\_frame}}
% Hardcode
\newcommand{\assign}{\helper{assign}}
\newcommand{\binop}{\helper{binop}}
% Reference interpreter
\newcommand{\match}{\helper{match}}
\newcommand{\hastype}{\helper{has\_type}}




%% Syntax
\section{Syntax of AL}
\label{syntax}

{
\renewcommand{\arraystretch}{0.8835}  % Decrease row spacing locally
\begin{align*}
\begin{array}{lcccrlr}
%
% Algorithm
  \text{Algorithm}\quad& A &\ni& a &::=& ~ \rel ~ (s, \seq e, \seq i) &\quad\text{(Relation)} \\
  &&&& | & ~ \fun ~ (s, \seq e, \seq i) &\quad\text{(Function)} \\
%
% Instruction
  \text{Instruction}\quad& I &\ni& i &::=& ~ \ifi ~ (e, \seq i, \seq i) &\quad\text{(If)} \\
    &&&& | & ~ \eitheri ~ (\seq i, \seq i) &\quad\text{(Either)} \\
    &&&& | & ~ \enteri ~ (e, e) &\quad\text{(Enter)} \\
    &&&& | & ~ \pushctxi ~ e &\quad\text{(Push Context)} \\
    &&&& | & ~ \pushi ~ e &\quad\text{(Push)} \\
    &&&& | & ~ \popctxi ~ e &\quad\text{(Pop Context)} \\
    &&&& | & ~ \popi ~ e &\quad\text{(Pop)} \\
    &&&& | & ~ \popni ~ (e, e) &\quad\text{(Pop N)} \\
    &&&& | & ~ \popalli ~ e &\quad\text{(Pop All)} \\
    &&&& | & ~ \leti ~ (e, e) &\quad\text{(Let)} \\
    &&&& | & ~ \trapi &\quad\text{(Trap)} \\
    &&&& | & ~ \returnreli &\quad\text{(Return Relation)} \\
    &&&& | & ~ \returnfunci ~ e &\quad\text{(Return Function)} \\
    &&&& | & ~ \executei ~ e &\quad\text{(Execute)} \\
    &&&& | & ~ \calli ~ (s, s, \seq{e}) &\quad\text{(Let Call)} \\
    &&&& | & ~ \replacei ~ (e, p^+, e) &\quad\text{(Replace)} \\
%
% Expression
  \text{Expression}\quad& E &\ni& e &::=& ~ \vare ~ s &\quad\text{(Variable)} \\
    &&&& | & ~ \nume ~ n &\quad\text{(Number)} \\
    &&&& | & ~ \boole ~ b &\quad\text{(Boolean)} \\
    &&&& | & ~ \fnamee ~ s &\quad\text{(Function Name)} \\
    &&&& | & ~ \liste ~ \seq e &\quad\text{(List)} \\
    &&&& | & ~ \stre ~ \seq{(s, e)} &\quad\text{(Record)} \\
    &&&& | & ~ \tupe ~ \seq e &\quad\text{(Tuple)} \\
    &&&& | & ~ \casee ~ (s, \seq e) &\quad\text{(Tagged Tuple)} \\
    &&&& | & ~ \une ~ (unop, e) &\quad\text{(Unary Operation)} \\
    &&&& | & ~ \bine ~ (binop, e, e) &\quad\text{(Binary Operation)} \\
    &&&& | & ~ \acce ~ (e, p) &\quad\text{(Access)} \\
    &&&& | & ~ \upde ~ (e, p^+, e) &\quad\text{(Update)} \\
    &&&& | & ~ \cate ~ (e, e) &\quad\text{(Concatenation)} \\
    &&&& | & ~ \compe ~ (e, e) &\quad\text{(Composition)} \\
    &&&& | & ~ \meme ~ (e, e) &\quad\text{(Membership)} \\
    &&&& | & ~ \choosee ~ e &\quad\text{(Choose)} \\
    &&&& | & ~ \lene ~ e &\quad\text{(Length)} \\
    &&&& | & ~ \iscaseofe ~ (e, s) &\quad\text{(Check Tag)} \\
    &&&& | & ~ \getcurctxe ~ s &\quad\text{(Get Current Context)} \\
    &&&& | & ~ \ctxkinde ~ s &\quad\text{(Context Kind)} \\
    &&&& | & ~ \itere ~ (e, iter, \seq{s}) &\quad\text{(Iteration)} \\
    &&&& | & ~ \matche ~ (e, e) &\quad\text{(Match)} \\
    &&&& | & ~ \hastypee ~ (e, s) &\quad\text{(Has Type)} \\
\end{array}
\end{align*}
}

\newpage
\begin{align*}
\begin{array}{lcccrlr}
%
% Path
  \text{Path}\quad& P &\ni& p &::=& ~ \idxp ~ e ~ | ~ \slicep ~ (e, e) ~ | ~ \dotp ~ s \\
%
% Iter
  \text{Iter}\quad& Iter &\ni& iter &::=& ~ \listiter ~ | ~ \listniter ~ e ~|~ \listidxiter ~ (s, e) \\
%
% Operator
  \text{Unary Operator}\quad& Unop &\ni& unop &::=& ~ \notop ~ | ~ \minusop \\
  \text{Binary Operator}\quad& Binop &\ni& binop &::=& ~ \addop ~ | ~ \subop ~ | ~ \mulop \\
    &&&& | & \divop ~ | ~ \modop ~ | ~ \expop \\
    &&&& | & \implop ~ | ~ \equivop ~ | ~ \andop \\
    &&&& | & \orop ~ | ~ \eqop ~ | ~ \neop ~ | ~ \ltop \\
    &&&& | & \gtop ~ | ~ \leop ~ | ~ \geop \\
% Primitives
  \text{String}\quad& \mathbb S &\ni& s \\
  \text{Integer}\quad& \mathbb Z &\ni& n \\
  \text{Boolean}\quad& \mathbb B &\ni& b \\
\end{array}
\end{align*}

% algorithm
An algorithm is either an AL relation or an AL function, corresponding to the
relation and the function definitions in the DSL.
% instruction
An AL instruction is \ifi{} for conditionally choosing a branch, \eitheri{} for
nondeterministically choosing a branch, \enteri{} for entering a block,
\pushctxi{} for pushing a Wasm context, \pushi{} for pushing a Wasm value,
\popctxi{} for popping a Wasm context, \popi{} for popping a Wasm value,
\popni{} for popping $n$ Wasm values, \popalli{} for popping all Wasm values
within a Wasm context, \leti{} for let binding, \trapi{} for trapping,
\returnreli{} for returning from an AL relation, \returnfunci{} for returning
from an AL function, \executei{} for executing given Wasm instructions,
\calli{} for an AL function call with let binding, or \replacei{} for replacing
some mutable data structure.
% expression
An expression is a variable, number, boolean, AL function name, list, record
(or struct), tuple, tagged tuple, unary or binary operation, data structure
access or update, list or record concatenation, membership check, element
selection, length retrieval, tag check, Wasm context retrieval, Wasm context
kind check, iteration, match relation, or type relation.


\begin{align*}
\begin{array}{lcccrlr}
%
% State
  \text{State}\quad& \Sigma &\ni& \sigma & ::=& ~ \seq a, w, k \\
%
% Wasm state
  \text{Wasm State}\quad& W &\ni& w &::=& ~ \seq{we}, \seq{wi}, sto \\
%
% Wasm Entry
  \text{Wasm Entry}\quad& WE &\ni& we &::=& ~ wv ~ | ~ wc \\
%
% Wasm Value
  \text{Wasm Value}\quad& WV &\ni& wv &::=& ~ \casev ~ (s, \seq v) \\
%
% Wasm Context
  \text{Wasm Context}\quad& WC &\ni& wc &::=& ~ \casev ~ (s, \seq v) \\
%
% Wasm Instruction
  \text{Wasm Instruction}\quad& WI &\ni& wi &::=& ~ \casev ~ (s, \seq v) \\
%
% Store
  \text{Store}\quad& Store &\ni& sto &::=& ~ \seq{(s, v)} \\
%
% Continuation
  \text{Continuation}\quad & K &\ni& k &::=& ~ \mt &\quad\text{(Empty)} \\
    &&&& | & ~ \toplevelcall ~ (s, \seq v) &\quad\text{(Top-level Call)} \\
    &&&& | & ~ \call ~ (s, s, \seq v, k) &\quad\text{(Call)} \\
    &&&& | & ~ \exe ~ (\seq{wi}, k) &\quad\text{(Execute)} \\
    &&&& | & ~ \wasm ~ (\seq{wc}, k) &\quad\text{(Wasm)} \\
    &&&& | & ~ \algo ~ c &\quad\text{(Algorithm)} \\
    &&&& | & ~ \ret ~ (v, k) &\quad\text{(Return)} \\
%
% Context
  \text{Context}\quad& C &\ni& c &::=& ~ (\seq i, \mu, \seq{wc}, k) \\
%
% Environment
  \text{Environment}\quad& M &\ni& \mu &::=& ~ \seq{[s \mapsto v]} \\
\end{array}
\end{align*}

\newpage
\begin{align*}
\begin{array}{lcccrlr}
%
% Value
  \text{Value}\quad& V &\ni& v &::=& ~ \numv ~ n &\quad\text{(Number)} \\
    &&&& | & ~ \boolv ~ b &\quad\text{(Boolean)} \\
    &&&& | & ~ \fnamev ~ s &\quad\text{(Function Name)} \\
    &&&& | & ~ \listv ~ \seq v &\quad\text{(List)} \\
    &&&& | & ~ \strv ~ \seq{(s, v)} &\quad\text{(Record)} \\
    &&&& | & ~ \tupv ~ \seq v &\quad\text{(Tuple)} \\
    &&&& | & ~ \casev ~ (s, \seq v) &\quad\text{(Tagged Tuple)} \\
    &&&& | & ~ \trapv &\quad\text{(Trap)} \\
    &&&& | & ~ \storev &\quad\text{(Store)} \\
\end{array}
\end{align*}

% State
An AL state consists of a sequence of algorithms, a Wasm state, and a
continuation.
% Wasm State
A Wasm state consists of an interleaved stack, a Wasm instruction stack, and a
store.
% Wasm Entry
An interleaved stack consists of two entries: a Wasm value and a Wasm context.
% Wasm Value & Wasm Context & Wasm Instruction
A Wasm value, a Wasm context, and a Wasm instruction each are expressed as an
AL value $\casev$.
% Store
A store is expressed as a sequence of field name and AL value pairs.
% Continuation
A continuation is \mt{} for an empty continuation, \toplevelcall{} for
top-level function call, \call{} for a function call with let binding, \exe{}
for executing given Wasm instructions, \wasm{} for executing a Wasm instruction
in the instruction stack, \algo{} for interpreting AL instructions in an
algorithm, or \ret{} for returning from an AL function.
% Env
An environment is a finite mapping from variable names to AL values.
% Context
An AL context consists of
% Value
An AL value is a number, boolean, function name, list, record, tuple, tagged tuple,
trap, or store.


% Terminology
In this section, AL-specific terms (state, value, function, and instruction)
are abbreviated as simply state, value, function, and instruction, while Wasm
terms remain unchanged.




\newpage
%% Semantics
\section{Semantics of AL}
\label{semantics}

%% Continuation

\begin{gather*}
\boxed{\leadsto \subseteq \Sigma \times \Sigma} \\
%
% TopLevelCall
\newline \\
  \\
  \hline
  (\seq{a}, w, \toplevelcall ~ (s, \seq v)) \leadsto (\seq{a}, w, \createalgo(\seq a, s, \seq v, \mt)) \\
%
% Call
\newline \\
  \\
  \hline
  (\seq{a}, w, \call ~ (s_{var}, s_{name}, \seq v, k)) \leadsto
  (\seq{a}, w, \createalgo(\seq a, s_{name}, \seq v, \call ~ (s_{var}, s_{name}, \seq v, k))) \\
%
% Execute-empty
\newline \\
  \\
  \hline
  (\seq{a}, w, \exe ~ (\epsilon, k)) \leadsto (\seq{a}, w, k) \\
%
% Execute-instr
\newline \\
  \casev ~ (s, \seq v) = wi \\
  \hline
  (\seq{a}, w, \exe ~ (wi ~ \seq{wi}, k)) \leadsto
  (\seq{a}, w, \createalgo(\seq a, s, \seq v, \exe ~ (\seq{wi}, k))) \\
%
% Wasm-empty
\newline \\
  \\
  \hline
  (\seq{a}, w, \wasm ~ (\epsilon, k)) \leadsto (\seq{a}, w, k) \\
%
% Wasm-instr
\newline \\
  (w', \casev ~ (s, \seq v)) = \popwasminstr(w) \\
  \hline
  (\seq{a}, w, \wasm ~ (wc^+, k))
  \leadsto
  (\seq{a}, w', \createalgo(\seq a, s, \seq v, \wasm ~ (wc^+, k))) \\
%
% Al-empty
\newline \\
  \\
  \hline
  (\seq{a}, w, \algo ~ (\epsilon, \mu, \seq{wc}, k)) \leadsto (\seq{a}, w, k) \\
%
% Al-instr
\newline \\
  \seq{a}, w, (\seq{i_1}, \mu, \seq{wc}, k) \vdash i_0 \Rightarrow (w', k') \\
  \hline
  (\seq{a}, w, \algo ~ (i_0 ~ \seq{i_1}, \mu, \seq{wc}, k)) \leadsto (\seq{a}, w', k') \\
%
% Return
\newline \\
  \mu = \getenv(c) \qquad c' = \setenv(c, \mu[s_{var} \mapsto v]) \\
  \hline
  (\seq{a}, w, \ret ~ (v, \call ~ (s_{var}, s_{name}, \seq v, \algo ~ c)) \leadsto
  (\seq a, w, \algo ~ c') \\
\end{gather*}

The semantics of AL is defined by a state transition system.
% TopLevelCall
Given the algorithms $\seq a$ generated from the DSL and the Wasm state $w$, a
top-level function $s$ can be invoked with arguments $\seq v$ to perform
either module instantiation or function invocation:
$(\seq a, w, \toplevelcall ~ (s, \seq v))$.
$\toplevelcall ~ (s, \seq v)${} changes to \algo{} with the function name $s$, the arguments
$\seq v$, and \mt{}.
% Empty
\mt{} is an empty continuation, representing the end of the transition, so no
further transition occurs.
% Call
Similarly to top-level call, $\call~ (s_{var}, s_{name}, \seq v, k)${} changes
to \algo{} with the function name $s_{name}$ and the arguments $\seq v$, but
with the current continuation nested within it.
%After the call, a return value is bound by $s_{var}$ in the \ret{} transition.
% Execute
$\exe ~ (\seq{wi}, k)${} executes the Wasm instruction sequence $\seq{wi}$ one
by one, each containing a relation name and arguments.
The continuation changes to \algo{} with the relation name, the arguments, and
the current continuation, with the Wasm instruction being popped.
% Wasm
In $\wasm ~ (\seq{wc}, k)${}, a Wasm instruction is popped from
the Wasm instruction stack and executed until the Wasm context sequence
$\seq{wc}$ is exhausted.
This execution changes the continuation to \algo{}, with the relation name and
the arguments of the Wasm instruction, and the current continuation nested
within it.
% Algo
In $\algo ~ (\seq i, \mu, \seq{wc}, k)${}, the body instructions $\seq i$ are
executed sequentially, allowing transitions to \call{}, \exe{}, \wasm{},
\ret{}, or \algo{}.
% Return
The execution of a function call concludes with a return instruction, changing
the continuation to $\ret ~ v${}.
If the function call originates from \call{}, the return value $v$ is assigned
to the variable $s_{var}$.
If it originates from \toplevelcall{}, the inner continuation $k$ is always
\mt, so the entire execution completes with the return value $v$:
$
(\seq a, w, \toplevelcall ~ (s, \seq v))
\leadsto^*
(\seq a, w', \ret ~ (v, \mt))
$.




%% Instruction

\begin{gather*}
  \boxed{\seq{a}, ~ w, ~ c \vdash i \Rightarrow w, ~ k} \\
%
% If-true
\newline \\
  w, \getenv(c) \vdash e \Rightarrow v \qquad
  \istrue(v) \\
  \hline
  \seq{a}, w, c \vdash \ifi ~ (e, \seq{i_1}, \seq{i_2}) \Rightarrow
  (w, \algo ~ (\prependinstr(c, \seq{i_1}))) \\
%
% If-false
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \qquad
  \neg \istrue(v) \\
  \hline
  \seq{a}, w, c \vdash \ifi ~ (e, \seq{i_1}, \seq{i_2}) \Rightarrow
  (w, \algo ~ (\prependinstr(c, \seq{i_2}))) \\
%
% Either-1
\newline \\
  \\
  \hline
  \seq{a}, w, c \vdash \eitheri ~ (\seq{i_1}, \seq{i_2}) \Rightarrow
  (w, \algo ~ (\prependinstr(c, \seq{i_1}))) \\
%
% Either-2
\newline \\
  \\
  \hline
  \seq{a}, w, c \vdash \eitheri ~ (\seq{i_1}, \seq{i_2}) \Rightarrow
  (w, \algo ~ (\prependinstr(c, \seq{i_2}))) \\
%
% Enter
\newline \\
  (\seq{we}, \seq{wi}, sto) = w \qquad
  (i^*, \mu, wc_1 ~ ... ~ wc_n, k) = c \\
  w, \mu \vdash e_1 \Rightarrow wc \qquad
  w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{wi_1} \\
  wi = \getendinstr(wc) \qquad
  wi_1 = \getendinstr(wc_1) \quad ... \quad wi_n = \getendinstr(wc_n) \\
  wi_2^* = wi_1^* ~ wi ~ wi_1 ~ ... ~ wi_n \\
  \hline
  \seq{a}, w, c \vdash \enteri ~ (e_1, e_2)
  \Rightarrow
  (
    (wc ~ \seq{we}, wi_2^* ~ \seq{wi}, sto),
    \wasm ~ (wc ~ wc_1 ~ ... ~ wc_n, \algo ~ (i^*, \mu, \epsilon, k))
  ) \\
%
% PushCtx
\newline \\
  w, \getenv(c) \vdash e \Rightarrow wc \\
  \hline
  \seq{a}, w, c \vdash \pushctxi ~ e
  \Rightarrow
  (\push(w, wc), \algo ~ (\addctx(c, wc))) \\
%
% Push
\newline \\
  w, \getenv(c) \vdash e \Rightarrow wv \\
  \hline
  \seq{a}, w, c \vdash \pushi ~ e \Rightarrow (\push(w, wv), \algo ~ c) \\
%
% PopCtx
\newline \\
  wc ~ \seq{we'} = \exit_{WasmEntry}(\seq{we}) \qquad
  \mu = \assign(\getenv(c), e, wc) \\
  \seq{wi'} = \exit_{WasmInstr}(\seq{wi}) \qquad
  c' = \exit_{C}(c) \\
  \hline
  \seq{a}, (\seq{we}, \seq{wi}, sto), c \vdash \popctxi ~ e
  \Rightarrow
  ((\seq{we'}, \seq{wi'}, sto), \algo ~ (\setenv(c', \mu))) \\
%
% Pop
\newline \\
  (w', wv) = \pop(w) \qquad
  \mu' = \assign(\getenv(c), e, wv) \\
  \hline
  \seq{a}, w, c \vdash \popi ~ e \Rightarrow (w', \algo ~ (\setenv(c, \mu'))) \\
%
% PopN
\newline \\
  \mu = \getenv(c) \qquad
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \\
  (w', wv^n) = \popn(w, n) \qquad
  \mu' = \assign(\mu, e_1, \listv ~ wv^n) \\
  \hline
  \seq{a}, w, c \vdash \popni ~ (e_1, e_2) \Rightarrow
  (w', \algo ~ (\setenv(c, \mu'))) \\
%
% PopAll
\newline \\
  (\seq{wv}, \seq{we'}) = \splitctx(\seq{we}) \qquad
  \mu' = \assign(\getenv(c), e, \liste ~ \seq{wv}) \\
  \hline
  \seq{a}, (\seq{we}, \seq{wi}, sto), c \vdash \popalli ~ e
  \Rightarrow
  ((\seq{we'}, \seq{wi}, sto), \algo ~ (\setenv(c, \mu'))) \\
%
% Let
\newline \\
  \mu = \getenv(c) \qquad
  w, \mu \vdash e_2 \Rightarrow v \qquad
  \mu' = \assign(\mu, e_1, v) \\
  \hline
  \seq{a}, w, c \vdash \leti ~ (e_1, e_2)
  \Rightarrow
  (w, \setenv(c, \mu')) \\
%
% Trap
\newline \\
  \\
  \hline
  \seq{a}, w, c \vdash \trapi \Rightarrow (w, \ret ~ (\trapv, \mt)) \\
%
% Return-rule
\newline \\
  \\
  \hline
  \seq{a}, w, (\seq{i}, \mu, wc^*, k) \vdash \returnreli \Rightarrow (w, k) \\
%
% Return-func
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, (\seq{i}, \mu, wc^*, k) \vdash \returnfunci ~ e \Rightarrow
  (w, \ret ~ (v, k)) \\
%
% Execute
\newline \\
  w, \getenv(c) \vdash e \Rightarrow \listv ~ wi^* \\
  \hline
  \seq{a}, w, c \vdash \executei ~ e \Rightarrow
  (w, \exe ~ (wi^*, \algo ~ c)) \\
%
% Call-fname
\newline \\
  \mu = \getenv(c) \qquad
  \fnamev ~ s_3 = \mu(s_2) \qquad
  w, \mu \vdash e_1 \Rightarrow v_1 \quad ... \quad
  w, \mu \vdash e_n \Rightarrow v_n \\
  \hline
  \seq{a}, w, c \vdash \calli ~ (s_1, s_2, e_1 ~ ... ~ e_n) \Rightarrow
  (w, \call ~ (s_1, s_3, v_1 ~ ... ~ v_n, \algo ~ c)) \\
%
% Call-fname
\newline \\
  \mu = \getenv(c) \qquad
  s_2 \not\in \domain(\mu) \qquad
  w, \mu \vdash e_1 \Rightarrow v_1 \quad ... \quad
  w, \mu \vdash e_n \Rightarrow v_n \\
  \hline
  \seq{a}, w, c \vdash \calli ~ (s_1, s_2, \seq e) \Rightarrow
  (w, \call ~ (s_1, s_2, v_1 ~ ... ~ v_n, \algo ~ c)) \\
% TODO: get cur frame ...
%
% Replace-frame
\newline \\
\text{NOTE: $e_1$ is either store or current frame} \\
  \mu = \getenv(c) \qquad
  w, \mu \vdash e_1 \Rightarrow  \casev ~ (\text{"FRAME"}, v_{11} ~ v_{12}) \qquad
  w, \mu \vdash e_2 \Rightarrow v_2 \\
  v_3 = \update(w, \mu, v_{12}, p^+, v_2) \\
  \hline
  \seq{a}, w, c \vdash \replacei ~ (e_1, p^+, e_2) \Rightarrow
  (\setcurframe(w, \casev ~ (\text{"FRAME"}, v_{11} ~ v_3)), \algo ~ c) \\
%
% Replace-store
\newline \\
  \mu = \getenv(c) \qquad
  w, \mu \vdash e_1 \Rightarrow \storev \qquad
  w, \mu \vdash e_2 \Rightarrow v_2 \\
  \strv ~ sto = \update(w, \mu, \strv (\getstore(w)), p^+, v_2) \\
  \hline
  \seq{a}, w, c \vdash \replacei ~ (e_1, p^+, e_2)
  \Rightarrow (\setstore(w, sto), c) \\
\end{gather*}

% TODO: wv -> wc/we, k -> algo c, free variables
Given algorithms $\seq a$, a Wasm state $w$, and a continuation $k$, executing an
instruction produces an updated Wasm state and a new continuation.
The input continuation is always \algo{}, with the arguments encapsulated
within it rather than enumerated individually.
% If
\ifi{} instruction evaluates $e$ and branches to $\seq i_1$ if the result is
true, or $\seq i_2$ otherwise.
% Either
\eitheri{} instruction nondeterministically selects either $\seq i_1$ or $\seq
i_2$.
% Enter
\enteri{} instruction evaluates $e_1$, pushing the resulting Wasm context $v_1$
to the Wasm value stack.
It evaluates $e_2$ to get the Wasm instruction sequence $\seq{v_2}$.
Then, end instructions of the Wasm context $v_1$ and the Wasm contexts
$\seq{wc}$ in the
continuation $k$ are appended to $\seq v_2$ and pushed to the Wasm instruction
stack.
Finally, it changes the continuation to \wasm{} with the Wasm contexts $c$ and
the continuation $k$ with its Wasm contexts cleared.
% PushCtx
\pushctxi{} instruction evaluates $e$, pushing the resulting Wasm context $v$
to the Wasm value stack and the continuation $k$.
% Push
\pushi{} instruction evaluates $e$, pushing the resulting value to the Wasm
value stack.
% PopCtx
\popctxi{} instruction pops all Wasm value up to and including a Wasm context
$wv_{ctx}$ from the Wasm value stack and all Wasm instructions up to and
including an end instruction from the Wasm instruction stack.
It also pops the Wasm context in the continuation $k$.
Then, it assign the Wasm context $wv_{ctx}$ to $e$.
% Pop
\popi{} instruction pops a Wasm value from the Wasm value stack and assign the
value to $e$.
% PopN
\popni{} instruction evalutes $e_2$ to get $n$, pops $n$ Wasm values from the
Wasm value stack, and assign the values to $e_1$.
% PopAll
\popalli{} instruction pops all the Wasm values up to, but not including, a
Wasm context from the Wasm value stack and assign the values to $e$.
% Let
\leti{} instruction evaluates $e_2$ and assign the resulting value to $e_1$.
% Trap
\trapi{} instruction results in \ret{} with \trapv{} and \mt{} to terminates
the execution.
% ReturnRel
\returnreli{} instruction results in the inner continuation $k$, indicating a
return from a relation algorithm.
% ReturnFunc
\returnfunci{} instruction evaluates $e$, results in \ret{} with the resulting
value and the inner continuation $k$.
% Execute
\executei{} instruction evaluates $e$ and result in \exe{} with the resulting
values $\seq v$ and the current continuation $k$.
% Call
The \calli{} instruction checks the environment; if $s_1$ exists, it gets the
function name; otherwise, it uses $s_1$ as the function name.
It evaluates $\seq e$ and construct \call{} with binding variable $s_0$, the
function name, and the resulting values.
% Replace
\replacei{} evaluates $e_1$ and $e_2$ to $v_1$ and $v_2$.
If $v_1$ is frame, it accesses the frame with $p$ and update the value to
$v_2$; if $v_1$ is store, it accesses the store with $p$ and update the value
to $v_2$.




%% Expression

\begin{gather*}
  \boxed{w, \mu \vdash e \Rightarrow v} \\
%
% Var
\newline \\
  v = \mu(s) \\
  \hline
  w, \mu \vdash \vare ~ s \Rightarrow v \\
%
% Num
\newline \\
  \hline
  w, \mu \vdash \nume ~ n \Rightarrow \numv ~ n \\
%
% Bool
\newline \\
  \hline
  w, \mu \vdash \boole ~ b \Rightarrow \boolv ~ b \\
%
% Fname
\newline \\
  \hline
  w, \mu \vdash \fnamee ~ s \Rightarrow \fnamev ~ s \\
%
% List
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad ... \quad
  w, \mu \vdash e_n \Rightarrow v_n \\
  \hline
  w, \mu \vdash \liste ~ e_1 ~ ... ~ e_n \Rightarrow \listv ~ v_1 ~ ... ~ v_n \\
%
% Str
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad ... \quad
  w, \mu \vdash e_n \Rightarrow v_n \\
  \hline
  w, \mu \vdash \stre ~ (s_1, e_1) ~ ... ~ (s_n, e_n) \Rightarrow
  \strv ~ (s_1, v_1) ~ ... ~ (s_n, v_n) \\
%
% Tup
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad ... \quad
  w, \mu \vdash e_n \Rightarrow v_n \\
  \hline
  w, \mu \vdash \tupe ~ e_1 ~ ... ~ e_n \Rightarrow \tupv ~ v_1 ~ ... ~ v_n \\
%
% Case
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad ... \quad
  w, \mu \vdash e_n \Rightarrow v_n \\
  \hline
  w, \mu \vdash \casee ~ (s, e_1 ~ ... ~ e_n) \Rightarrow \casev ~ (s, v_1 ~ ... ~ v_n) \\
%
% Un
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \une ~ (unop, e) \Rightarrow \unop(unop, v) \\
%
% Bin
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \bine ~ (binop, e_1, e_2) \Rightarrow \binop(binop, v_1, v_2) \\
%
% Acc
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \acce ~ (e, p) \Rightarrow \access(w, \mu, v, p) \\
%
% Upd
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \upde ~ (e_1, p^+, e_2) \Rightarrow \update(w, \mu, v_1, p^+, v_2) \\
%
% Cat
\newline \\
   w, \mu \vdash e_1 \Rightarrow \listv ~ \seq{v_1} \qquad
   w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \hline
  w, \mu \vdash \cate ~ (e_1, e_2) \Rightarrow \listv ~ (\seq{v_1} ~ \seq{v_1}) \\
%
% Comp
\newline \\
   w, \mu \vdash e_1 \Rightarrow \strv ~ \seq{(s_1, v_1)} \qquad
   w, \mu \vdash e_2 \Rightarrow \strv ~ \seq{(s_2, v_2)} \\
  \hline
  w, \mu \vdash \compe ~ (e_1, e_2) \Rightarrow \strv ~ (\seq{(s_1, v_1)} ~ \seq{(s_2, v_2)}) \\
%
% Mem
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad
  w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \hline
  w, \mu \vdash \meme ~ (e_1, e_2) \Rightarrow \boolv ~ (v_1 \in \seq{v_2}) \\
%
% Choose
\newline \\
  w, \mu \vdash e \Rightarrow \listv ~ \seq{v} \qquad
  v \in \seq{v} \\
  \hline
  w, \mu \vdash \choosee ~ e \Rightarrow v \\
%
% Len
\newline \\
  w, \mu \vdash e \Rightarrow \listv ~ \seq{v} \\
  \hline
  w, \mu \vdash \lene ~ e \Rightarrow \numv ~ |\seq v| \\
%
% IsCaseOf
\newline \\
  w, \mu \vdash e \Rightarrow \casev ~ (s', \seq{v}) \\
  \hline
  w, \mu \vdash \iscaseofe ~ (e, s) \Rightarrow \boolv ~ (s = s') \\
%
% GetCurCtx
\newline \\
  v_{ctx} = \getcurctx(w, s) \\
  \hline
  w, \mu \vdash \getcurctxe ~ s \Rightarrow v_{ctx} \\
%
% CtxKind
\newline \\
  \casev (s', \seq v) = \getcurctx(w, s) \\
  \hline
  w, \mu \vdash \ctxkinde ~ s \Rightarrow \boolv ~ (s = s') \\
%
% Iter-
\newline \\
  \,~\mu(s_1) = \listv ~ (v_{11} ~ ... ~ v_{1n}) \quad ... \quad
  \mu(s_m) = \listv ~ (v_{m1} ~ ... ~ v_{mn}) \\
  \mu_1 = \mu[s_1 \mapsto v_{11}, ~ ... ~ s_m \mapsto v_{m1}] \quad ... \quad
  \mu_n = \mu[s_1 \mapsto v_{1n}, ~ ... ~ s_m \mapsto v_{mn}] \\
  w, \mu_1 \vdash e \Rightarrow v_1 \quad ... \quad
  w, \mu_n \vdash e \Rightarrow v_n \\
  \hline
  w, \mu \vdash \itere ~ (e, \listiter, s_1 ~ ... ~ s_m) \Rightarrow
  \listv ~ v_1 ~ ... ~ v_n \\
%
% Iter-n
\newline \\
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \\
  \,~\mu(s_1) = \listv ~ (v_{11} ~ ... ~ v_{1n}) \quad ... \quad
  \mu(s_m) = \listv ~ (v_{m1} ~ ... ~ v_{mn}) \\
  \mu_1 = \mu[s_1 \mapsto v_{11}, ~ ... ~ s_m \mapsto v_{m1}] \quad ... \quad
  \mu_n = \mu[s_1 \mapsto v_{1n}, ~ ... ~ s_m \mapsto v_{mn}] \\
  w, \mu_1 \vdash e \Rightarrow v_1 \quad ... \quad
  w, \mu_n \vdash e \Rightarrow v_n \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listniter ~ e_2, s_1 ~ ... s_m) \Rightarrow
  \listv ~ v_1 ~ ... ~ v_n \\
%
% Iter-idx
\newline \\
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \\
  \mu_1 = \mu[s_1 \mapsto \numv ~ 0, ~ ... ~ s_m \mapsto \numv ~ 0] \quad ... \quad
  \mu_n = \mu[s_1 \mapsto \numv ~ n, ~ ... ~ s_m \mapsto \numv ~ n] \\
  w, \mu_1 \vdash e \Rightarrow v_1 \quad ... \quad
  w, \mu_n \vdash e \Rightarrow v_n \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listidxiter ~ e_2, s_1 ~ ... ~ s_m) \Rightarrow
  \listv ~ v_1 ~ ... ~ v_n \\
%
% Match
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \qquad
  w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \matche ~ (e_1, e_2) \Rightarrow \boolv ~ (\match(v_1, v_2)) \\
%
% HasType
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \hastypee ~ (e, s) \Rightarrow \boolv ~ (\hastype(v, s)) \\
\end{gather*}

Given Wasm state $w$, and an environment $\mu$, an expression evaluates to a
value.
% Var
\vare{} expression looks up the environment and gets the value.
% Num Bool Fname
\nume{}, \boole{}, and \fnamee{} expressions directly reduce to \numv{},
\boolv{}, and \fnamev{}, respectively.
% Tuple Case List Struct
\liste{}, \stre{}, \tupe{}, and \casee{} expressions evaluate their
sub-expressions and reduce to \listv{}, \strv{}, \tupv{}, and \casev{},
respectively.
% Un Bin
\une{} and \bine{} expression evaluate their sub-expressions and perform
\unop{} and \binop{}, respectively.
% Acc
\acce{} expression evaluates $e$ and accesses the resulting value using a path
$p$.
% Upd
\upde{} expression evaluates $e_1$ and $e_2$ to $v_1$ and $v_2$, and updates
the value at location $v_1$ along paths $\seq p$ to the value $v_2$.
% Cat Comp
\cate{} and \compe{} expressions each evaluate two sub-expressions,
concatenating the resulting lists and resulting records, respectively.
% Mem
\meme{} expression evaluates $e_1$ and $e_2$ to the value $v_1$ and $\listv ~
\seq v_2$, and checks whether $v_1$ is a member of $\seq v_2$.
% Choose Len
\choosee{} and \lene{} expression each evaluate $e$ to the list value $\listv
~ \seq v$, choosing an element from the list and calculating the length of the
list, respectively.
% IsCaseOf
\iscaseofe{} expression evaluates $e$ to the tagged tuple $\casev ~ (s', \seq
v)$ and checks whether the tag $s'$ matches $s$.
% GetCurCtx
\getcurctxe{} expression retrieves the current Wasm context from the Wasm value
stack.
% CtxKind
\ctxkinde{} expression retrieves the current Wasm context $\casev ~ (s', \seq
v)$ and checks whether the kind $s'$ matches $s$.
% Iter
\itere{} expression behaves differently depending on $iter$.
\listiter{} and \listniter{} are essentially equivalent.
They assume that the all the values mapped to the variables $\seq s$ by the
envinronment $\mu${} are list values with same length.
\listniter{} restricts the length to $n$, which is obtained from evaluating
$e_2$, while \listiter{} allows any length.
It generates a sequence of environments $\mu_2$ where the k-th environment maps
each variables to the k-th elements of the list.
Each environment $\mu_3$ is respectively used to evaluate $e_1$, resulting in
the list value $\listv ~ \seq{v'}$.
\listidxiter{} behaves similarly except that the variables $\seq s$ are
unbound.
It evaluates $e_2$ to obtain $n$ and then behaves like \listniter{} as if
the list values [0 ... n-1] was bound to the variables $s$.
% IsValid Match HasType
\matche{} and \hastypee{} expressions evaluate their sub-exressions and perform
\match{} and \hastype{}, respectively.
Note that \match{} and \hastype{} represent the match relation and the type
relation in the Wasm static semantics.
Their formalization is omitted as they are highly specific to Wasm and
excessively verbose.




%% Helper functions

\begin{align*}
%
% get_algo_name
\newline \\
  &\getalgoname(\rel ~ (s, \seq e, \seq i)) = s \\
  &\getalgoname(\fun ~ (s, \seq e, \seq i)) = s \\
%
% lookup
\newline \\
  &\lookup(a ~ \seq{a}, s) =
    \begin{cases}
      a &\quad\quad \premise{if}\quad ~ s = \getalgoname(a) \\
      \lookup(\seq{a}, s) &\quad\quad \premise{otherwise}
    \end{cases}
  \\
%
% create_algo
\newline \\
  &\createalgo(\seq a, s, \seq v, k) =
  \algo(\seq i, \mu, \epsilon, k) \\
  &\qquad\qquad\qquad\qquad\premise{if}\quad
  (\rel ~ (s, \seq e, \seq i) \quad\lor\quad \fun ~ (s, \seq e, \seq i)) = \lookup(\seq a, s)
  \quad\land\quad
  \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
%
% split_ctx
\newline \\
  &\splitctx(we ~ \seq{we}) =
    \begin{cases}
      (\epsilon, wc ~ \seq{we})
      &\quad\quad \premise{if}\quad
      we = wc \\
      (wv ~ \seq{wv}, \seq{we'})
      &\quad\quad \premise{if}\quad
      we = wv \quad\land\quad
      (\seq{wv}, \seq{we'}) = \splitctx(\seq{we})
    \end{cases}
  \\
%
% execute
\newline \\
  &\execute(v, k) = \exe(v, k) \\
%
% exit_context
\newline \\
  &\exit_{C}((\seq i, \mu, epsilon, k)) = (\seq i, \mu, \epsilon, \exit_K(k)) \\
  &\exit_{C}((\seq i, \mu, c ~ \seq c, k)) = (\seq i, \mu, \seq c, k) \\
%
% exit_cont-wasm_0
\newline \\
  &\exit_{K}(\wasm ~ (\epsilon, k)) = \wasm ~ (\epsilon, \exit_{K}(k)) \\
% exit_cont-wasm_nonzero
  &\exit_{K}(\wasm ~ (c ~ \seq{c}, k)) = \wasm ~ (\seq{c}, k) \\
% exit_cont-al
  &\exit_{K}(\algo ~ c) = \algo ~ (\exit_C(c)) \\
%
% exit_wasm_instr-end
\newline \\
  &\exit_{WasmInstr}(wi ~ \seq{wi}) =
    \begin{cases}
      \seq{wi} &\quad\quad \premise{if}\quad ~ \isendinstr(wi) \\
      \exit_{WasmInstr}(\seq{wi}) &\quad\quad \premise{otherwise} \\
    \end{cases}
  \\
%
% exit_wasm_entry
\newline \\
  &\exit_{WasmEntry}(\seq{we}) = \seq{we_1}
  \quad\quad\premise{if}\quad ~ (\seq{we_0}, \seq{we_1}) = \splitctx(\seq{we}) \\
%
% get_env
\newline \\
  &\getenv((\seq i, \mu, wc^*, k)) = \mu \\
%
% set_env
\newline \\
  &\setenv((\seq i, \mu, wc^*, k), \mu') = (\seq i, \mu', wc^*, k) \\
%
% prepend_instr
\newline \\
  &\prependinstr((\seq i, \mu, wc^*, k), \seq{i'}) = (\seq{i'} ~ \seq i, \mu, wc^*, k) \\
%
% add_ctx
\newline \\
  &\addctx((\seq i, \mu, wc^*, k), wc') = (\seq i, \mu, wc' ~ wc^*, k) \\
%
% get_store
\newline \\
  &\getstore((\seq{we}, \seq{wi}, sto)) = sto \\
%
% set_store
\newline \\
  &\setstore((\seq{we}, \seq{wi}, sto), sto') = (\seq{we}, \seq{wi}, sto') \\
%
% pop_wasm_instr
\newline \\
  &\popwasminstr((\seq{we}, wi ~ \seq{wi}, sto)) = ((\seq{we}, \seq{wi}, sto), wi) \\
%
% push
\newline \\
  &\push((\seq{we}, \seq{wi}, sto), we) = (we ~ \seq{we}, \seq{wi}, sto) \\
%
% pop
\newline \\
  &\pop((we ~ \seq{we}, \seq{wi}, sto)) = ((\seq{we}, \seq{wi}, sto), we) \\
%
% popn
\newline \\
  &\popn((we^n ~ \seq{we}, \seq{wi}, sto), n) = ((\seq{we}, \seq{wi}, sto), we^n) \\
%
% unop
\newline \\
  &\unop(\notop, v) =
    \begin{cases}
      \boolv ~ true &\quad\quad\premise{if}\quad ~ \istrue(v) \\
      \boolv ~ false &\quad\quad\premise{otherwise} \\
    \end{cases}
  \\
  &\unop(\minusop, \numv ~ n) = \numv ~ (-n) \\
%
% get_cur_ctx
\newline \\
  &\getcurctx((\seq{wv}, \seq{wi}, sto)) =
  wv_{ctx} \quad\quad\premise{if}\quad ~ (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \\
%
% get_cur_frame-frame
\newline \\
  &\getcurframe((\seq{wv}, \seq{wi}, sto)) =
    \begin{cases}
      wv_{ctx} &\quad\quad\premise{if}\quad
      (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \quad\land\quad \isframe(wv_{ctx})\\
      \getcurframe(\seq{wv_1}) &\quad\quad\premise{if}\quad
      (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \quad\land\quad \neg \isframe(wv_{ctx}) \\
    \end{cases}
  \\
%
% set_cur_frame-frame
\newline \\
  &\setcurframe((\seq{wv}, \seq{wi}, sto), v_{frame})
  =
  \begin{cases}
    (\seq{wv_0} ~ v_{frame} ~ \seq{wv_1}, \seq{wi}, sto) \\
    \qquad\qquad\qquad\quad\premise{if}\quad
    (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \quad \isframe(wv_{ctx}) \\
    (\seq{wv_0} ~ wv_{ctx} ~ \setcurframe(\seq{wv_1}, v_{frame}), \seq{wi}, sto) \\
    \qquad\qquad\qquad\quad\premise{if}\quad
    (\seq{wv_0}, wv_{ctx} ~ \seq{wv_1}) = \splitctx(\seq{wv}) \quad \neg \isframe(wv_{ctx}) \\
  \end{cases}
  \\
%
% access-idx
\newline \\
  &\access(w, \mu, \listv ~ \seq{v}, \idxp ~ e) = \seq{v}[n]
  \qquad\qquad\qquad~\,\quad\premise{if}\quad w, \mu \vdash e \Rightarrow \numv ~ n \\
% access-slice
  &\access(w, \mu, \listv ~ \seq{v}, \slicep ~ (e_1, e_2)) = \seq{v}[n_1: n_2]
  \quad\quad\premise{if}\quad
  w, \mu \vdash e_1 \Rightarrow \numv ~ n_1 \quad\land\quad
  w, \mu \vdash e_2 \Rightarrow \numv ~ n_2 \\
% access-dot
  &\access(w, \mu, \strv ~ ((s_0, v_0) ~ \seq{(s_1, v_1)}), \dotp ~ s) =
  \begin{cases}
    v_0 &\quad\quad\premise{if}\quad s_0 = s \\
    \access(w, \mu, \strv ~ \seq{(s_1, v_1)}, \dotp ~ s) &\quad\quad\premise{otherwise} \\
  \end{cases}
  \\
% access-store
  &\access(w, \mu, \storev, p) =\access(w, \mu, \strv ~ sto, p)
  \quad\quad\premise{if}\quad w = (\seq{we}, \seq{wi}, sto)\\
%
% update
\newline \\
  % idx
  &\update(w, \mu, \listv ~ \seq{v}, (\idxp ~ e) ~ \seq{p}, v) =
  \listv ~ (\updateidx(\seq v, n, \update(w, \mu, \seq{v}[n], \seq{p}, v))) \\
  &\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\premise{if}\quad
  w, \mu \vdash e \Rightarrow \numv ~ n \\
  % slice
  &\update(w, \mu, \listv ~ \seq{v}, (\slicep ~ e) ~ \seq{p}, v) =
  \listv ~ (\updateslice(\seq v, n_1, n_2, \update(w, \mu, \seq{v_i}[n_1: n_2], \seq{p}, v))) \\
  &\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad\premise{if}\quad
  w, \mu \vdash e_1 \Rightarrow \numv ~ n_1 \quad\land\quad
  w, \mu \vdash e_2 \Rightarrow \numv ~ n_2 \\
  % dot
  &\update(w, \mu, \strv ~ \seq{(s, v)}, (\dotp ~ s') ~ \seq{p}, v)
  =
  \strv ~ (\updatedot(\seq{(s, v)}, s', \update(w, \mu, \access(v, \dotp ~ s'), \seq{p}, v))) \\
%
% update_idx
\newline \\
  &\updateidx(v_0 ~ \seq{v_1}, n, v_2) =
  \begin{cases}
    v_2 ~ \seq{v_1}
    &\quad\quad\premise{if}\quad n = 0 \\
    v_0 ~ \updateidx(\seq{v_1}, n-1, v_2)
    &\quad\quad\premise{if}\quad n > 0 \\
  \end{cases} \\
%
% update_slice
\newline \\
  &\updateslice(v_0^n ~ \seq{v_1}, 0, n, v_2^n) = v_2^n ~ \seq{v_1} \\
  &\updateslice(v_0 ~ \seq{v_1}, m, n, v_2^n) =  v_0 ~ \updateslice(\seq{v_1}, m-1, n, v_2)
  \quad\quad\premise{if}\quad m > 0 \\
%
% update_dot
\newline \\
  &\updatedot((s_0, v_0) ~ \seq{(s_1, v_1)}, s_2, v_2) =
  \begin{cases}
    (s_2, v_2) ~ \seq{(s_1, v_1)}
    &\quad\quad\premise{if}\quad s_0 = s_2 \\
    (s_0, v_0) ~ \updatedot(\seq{(s_1, v_1)}, s_2, v_2)
    &\quad\quad\premise{otherwise}
  \end{cases}
  \\
%
% get_end_algo
\newline \\
  &\getendinstr(wc) =
  \begin{cases}
    \casev ~ (\text{"EXITING"}, \epsilon) &\quad\quad\premise{if}\quad wc = \casev ~ (\text{"LABEL"}, \seq v)\\
    \casev ~ (\text{"RETURNING"}, \epsilon) &\quad\quad\premise{if}\quad wc = \casev ~ (\text{"FRAME"}, \seq v)
  \end{cases} \\
%
% is_end_instr
\newline \\
  &\isendinstr(wi) =
  \begin{cases}
    true &\quad\quad\premise{if}\quad wi = \casev ~ (\text{"EXITING"}, \epsilon) \quad\lor\quad wi = \casev ~ (\text{"RETURNING"}, \epsilon)\\
    false &\quad\quad\premise{otherwise}
  \end{cases} \\
%
% is_true
\newline \\
  &\istrue(v) =
  \begin{cases}
  b &\quad\quad\premise{if}\quad v = \boolv ~ b \\
  \forall v \in \seq v. \istrue (v) &\quad\quad\premise{if}\quad v = \listv ~ \seq v \\
  \end{cases} \\
%
% is_frame
\newline \\
  &\isframe(v) =
  \begin{cases}
    true
    &\quad\quad\premise{if}\quad v = \casev ~ (\text{"FRAME"}, \seq v) \\
    false &\quad\quad\premise{otherwise}\\
  \end{cases}
  \\
\end{align*}





