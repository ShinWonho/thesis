% !TEX root = main.tex

\chapter{Semantics}
\label{ch:semantics}
\noindent


% AL semantics formalize
%
%
% Prose notation:
% - Implicit when to exit:
%   • Returning from a function
%     When the end of a function is reached without a jump (i.e., return) or trap aborting it, then the following steps are performed.
%
%   • Exiting with label
%     When the end of a block is reached without a jump or trap aborting it, then the following steps are performed.
%
%   ! end of function/label is defined verbally, not in algorithmic notation
%
% - Separate context and instructions:
%   • Push ctx \& Jump instrs
%
%
% abstract machine of prose notation: vm
% 1. state: stack, store
% 2. cosumes sequence of WebAssembly instruction
% 3. mutate state
%
% - store
%   - instantiate -> alloc
%   - invoke -> use
% - stack contains value \& context
%   - value
%     ex: binop
%   - context
%     1) label: allow structured control flow (continuation)
%     2) frame: store call information (local variable, module instance)
%     - enter \& exit
%     - ex: loop, invoke
%     - ex: br, implicit exit
%
%
% - wrong interpretation of "end" in AL interpreter \red{(How long does it occur?)}
% - example

\red{TODO: update syntax}


\newcommand{\sem}[1]{[\![#1]\!]}
\newcommand{\seq}[1]{#1^*}



%% Symbol definition

\renewcommand{\symbol}[1]{\textbf{#1}}

% Algorithm
\newcommand{\rel}{\symbol{Rel}}
\newcommand{\fun}{\symbol{Fun}}

% Continuation
\newcommand{\mt}{\symbol{Empty}}
\newcommand{\toplevelcall}{\symbol{TopLevelCall}}
\newcommand{\call}{\symbol{Call}}
\newcommand{\wasm}{\symbol{Wasm}}
\newcommand{\exe}{\symbol{Execute}}
\newcommand{\algo}{\symbol{Algo}}
\newcommand{\ret}{\symbol{Return}}

% Instruction
\newcommand{\ifi}{\symbol{IfI}}
\newcommand{\eitheri}{\symbol{EitherI}}
\newcommand{\enteri}{\symbol{EnterI}}
\newcommand{\pushctxi}{\symbol{PushCtxI}}
\newcommand{\pushi}{\symbol{PushI}}
\newcommand{\popctxi}{\symbol{PopCtxI}}
\newcommand{\popi}{\symbol{PopI}}
\newcommand{\popni}{\symbol{PopNI}}
\newcommand{\popalli}{\symbol{PopAllI}}
\newcommand{\leti}{\symbol{LetI}}
\newcommand{\trapi}{\symbol{TrapI}}
\newcommand{\nopi}{\symbol{NopI}}
\newcommand{\returnrulei}{\symbol{ReturnRuleI}}
\newcommand{\returnfunci}{\symbol{ReturnFuncI}}
\newcommand{\executei}{\symbol{ExecuteI}}
\newcommand{\executeseqi}{\symbol{ExecuteSeqI}}
\newcommand{\calli}{\symbol{CallI}}
\newcommand{\replacei}{\symbol{ReplaceI}}

% Expression
\newcommand{\vare}{\symbol{VarE}}
\newcommand{\nume}{\symbol{NumE}}
\newcommand{\boole}{\symbol{BoolE}}
\newcommand{\fnamee}{\symbol{FnameE}}
\newcommand{\une}{\symbol{UnE}}
\newcommand{\bine}{\symbol{BinE}}
\newcommand{\acce}{\symbol{AccE}}
\newcommand{\upde}{\symbol{UpdE}}
\newcommand{\stre}{\symbol{StrE}}
\newcommand{\compe}{\symbol{CompE}}
\newcommand{\cate}{\symbol{CatE}}
\newcommand{\meme}{\symbol{MemE}}
\newcommand{\lene}{\symbol{LenE}}
\newcommand{\tupe}{\symbol{TupE}}
\newcommand{\casee}{\symbol{CaseE}}
\newcommand{\itere}{\symbol{IterE}}
\newcommand{\liste}{\symbol{ListE}}
\newcommand{\getcurctxe}{\symbol{GetCurContextE}}
\newcommand{\choosee}{\symbol{ChooseE}}
\newcommand{\iscaseofe}{\symbol{IsCaseOfE}}
\newcommand{\isvalide}{\symbol{IsValidE}}
\newcommand{\ctxkinde}{\symbol{CtxKindE}}
\newcommand{\matche}{\symbol{MatchE}}
\newcommand{\hastypee}{\symbol{HasTypeE}}

% Unary operator
\newcommand{\notop}{\symbol{NotOp}}
\newcommand{\minusop}{\symbol{MinusOp}}

% Binary operator
\newcommand{\addop}{\symbol{AddOp}}
\newcommand{\subop}{\symbol{SubOp}}
\newcommand{\mulop}{\symbol{MulOp}}
\newcommand{\divop}{\symbol{DivOp}}
\newcommand{\modop}{\symbol{ModOp}}
\newcommand{\expop}{\symbol{ExpOp}}
\newcommand{\implop}{\symbol{ImplOp}}
\newcommand{\equivop}{\symbol{EquivOp}}
\newcommand{\andop}{\symbol{AndOp}}
\newcommand{\orop}{\symbol{OrOp}}
\newcommand{\eqop}{\symbol{EqOp}}
\newcommand{\neop}{\symbol{NeOp}}
\newcommand{\ltop}{\symbol{LtOp}}
\newcommand{\gtop}{\symbol{GtOp}}
\newcommand{\leop}{\symbol{LeOp}}
\newcommand{\geop}{\symbol{GeOp}}

% Path
\newcommand{\idxp}{\symbol{Idx}}
\newcommand{\slicep}{\symbol{Slice}}
\newcommand{\dotp}{\symbol{Dot}}

% Iter
\newcommand{\listiter}{\symbol{List}}
\newcommand{\listniter}{\symbol{ListN}}
\newcommand{\listidxiter}{\symbol{Index}}

% Value
\newcommand{\numv}{\symbol{NumV}}
\newcommand{\boolv}{\symbol{BoolV}}
\newcommand{\listv}{\symbol{ListV}}
\newcommand{\strv}{\symbol{StrV}}
\newcommand{\casev}{\symbol{CaseV}}
\newcommand{\tupv}{\symbol{TupV}}
\newcommand{\fnamev}{\symbol{FnameV}}
\newcommand{\trapv}{\symbol{TrapV}}
\newcommand{\storev}{\symbol{StoreV}}




%% Helper function

\newcommand{\helper}[1]{\text{#1}}

% Helper function
\newcommand{\getalgoname}{\helper{get\_algo\_name}}
\newcommand{\lookup}{\helper{lookup}}
\newcommand{\execute}{\helper{execute}}
\newcommand{\exit}{\helper{exit}}
\newcommand{\duplicateenv}{\helper{duplicate\_env}}
\newcommand{\getctx}{\helper{get\_ctx}}
\newcommand{\addctx}{\helper{add\_ctx}}
\newcommand{\resetctx}{\helper{reset\_ctx}}
\newcommand{\getenv}{\helper{get\_env}}
\newcommand{\setenv}{\helper{set\_env}}
\newcommand{\prependinstr}{\helper{prepend\_instr}}
\newcommand{\push}{\helper{push}}
\newcommand{\pop}{\helper{pop}}
\newcommand{\popn}{\helper{popn}}
\newcommand{\unop}{\helper{unop}}
\newcommand{\splitctx}{\helper{split\_ctx}}
\newcommand{\getcurctx}{\helper{get\_cur\_ctx}}
\newcommand{\getcurframe}{\helper{get\_cur\_frame}}
\newcommand{\setcurframe}{\helper{set\_cur\_frame}}
\newcommand{\access}{\helper{access}}
\newcommand{\update}{\helper{update}}
\newcommand{\updateidx}{\helper{update\_idx}}
\newcommand{\updateslice}{\helper{update\_slice}}
\newcommand{\updatedot}{\helper{update\_dot}}
\newcommand{\getendalgo}{\helper{get\_end\_algo}}
\newcommand{\istrue}{\helper{is\_true}}
\newcommand{\isframe}{\helper{is\_frame}}
\newcommand{\zip}{\helper{zip}}
\newcommand{\fold}{\helper{fold}}
% How to express?
\newcommand{\domain}{\helper{domain}}
% Hardcode
\newcommand{\assign}{\helper{assign}}
\newcommand{\binop}{\helper{binop}}
% Reference interpreter
\newcommand{\isvalid}{\helper{is\_valid}}
\newcommand{\match}{\helper{match}}
\newcommand{\hastype}{\helper{has\_type}}




%% Syntax
\section{Syntax of AL}
\label{syntax}

\begin{align*}
\begin{array}{lcccrlr}
%
% State
  \text{State}\quad& \Sigma &\ni& \sigma & ::=& \seq a, w, k \\
%
% Algorithm
  \text{Algorithm}\quad& A &\ni& a &::=& ~ \rel ~ (s, \seq e, \seq i) &\quad\text{(Relation)} \\
  &&&& | & ~ \fun ~ (s, \seq e, \seq i) &\quad\text{(Function)} \\
%
% Wasm state
  \text{Wasm State}\quad& W &\ni& w &::=& \seq{wv}, \seq{wi}, sto \\
  \text{Wasm Value}\quad& WV &\ni& wv &::=& v \\
  \text{Wasm Instruction}\quad& WI &\ni& wi &::=& v \\
%
% Store
  \text{Store}\quad& Store &\ni& sto &::=& \seq{(s, v)} \\
%
% Continuation
  \text{Continuation}\quad & Cont &\ni& k &::=& ~ \mt &\quad\text{(Empty)} \\
    &&&& | & ~ \toplevelcall ~ (s, \seq v, k) &\quad\text{(Top-level Call)} \\
    &&&& | & ~ \call ~ (s, s, \seq v, k) &\quad\text{(Call)} \\
    &&&& | & ~ \wasm ~ (\seq c, k) &\quad\text{(Wasm)} \\
    &&&& | & ~ \exe ~ (wi, k) &\quad\text{(Execute)} \\
    &&&& | & ~ \algo ~ (\seq i, \mu, \seq c, k) &\quad\text{(Algorithm)} \\
    &&&& | & ~ \ret ~ (v, k) &\quad\text{(Return)} \\
%
% Environment
  \text{Environment}\quad& M &\ni& \mu &::=& \seq{[s \mapsto v]} \\
%
% Context
  \text{Context}\quad& C &\ni& c &::=& v \\
%
% Instruction
  \text{Instruction}\quad& I &\ni& i &::=& ~ \ifi ~ (e, \seq i, \seq i) &\quad\text{(If)} \\
    &&&& | & ~ \eitheri ~ (\seq i, \seq i) &\quad\text{(Either)} \\
    &&&& | & ~ \enteri ~ (e, e) &\quad\text{(Enter)} \\
    &&&& | & ~ \pushctxi ~ e &\quad\text{(Push Context)} \\
    &&&& | & ~ \pushi ~ e &\quad\text{(Push)} \\
    &&&& | & ~ \popctxi ~ e &\quad\text{(Pop Context)} \\
    &&&& | & ~ \popi ~ e &\quad\text{(Pop)} \\
    &&&& | & ~ \popni ~ (e, e) &\quad\text{(Pop N)} \\
    &&&& | & ~ \popalli ~ e &\quad\text{(Pop All)} \\
    &&&& | & ~ \leti ~ (e, e) &\quad\text{(Let)} \\
    &&&& | & ~ \trapi &\quad\text{(Trap)} \\
    &&&& | & ~ \returnrulei &\quad\text{(Return Relation)} \\
    &&&& | & ~ \returnfunci ~ e &\quad\text{(Return Function)} \\
    &&&& | & ~ \executei ~ e &\quad\text{(Execute)} \\
    &&&& | & ~ \executeseqi ~ e &\quad\text{(Execute Sequence)} \\
    &&&& | & ~ \calli ~ (s, s, \seq{e}) &\quad\text{(Let Call)} \\
    &&&& | & ~ \replacei ~ (e, \seq{p}, e) &\quad\text{(Replace)} \\
\end{array}
\end{align*}
\newpage
\begin{align*}
\begin{array}{lcccrlr}
%
% Expression
  \text{Expression}\quad& E &\ni& e &::=& ~ \vare ~ s &\quad\text{(Variable)} \\
    &&&& | & ~ \nume ~ n &\quad\text{(Number)} \\
    &&&& | & ~ \boole ~ b &\quad\text{(Boolean)} \\
    &&&& | & ~ \fnamee ~ s &\quad\text{(Function Name)} \\
    &&&& | & ~ \une ~ (unop, e) &\quad\text{(Unary Operation)} \\
    &&&& | & ~ \bine ~ (binop, e, e) &\quad\text{(Binary Operation)} \\
    &&&& | & ~ \acce ~ (e, p) &\quad\text{(Access)} \\
    &&&& | & ~ \upde ~ (e, \seq{p}, e) &\quad\text{(Update)} \\
    &&&& | & ~ \stre ~ \seq{(s, e)} &\quad\text{(Record)} \\
    &&&& | & ~ \compe ~ (e, e) &\quad\text{(Composition)} \\
    &&&& | & ~ \cate ~ (e, e) &\quad\text{(Concatenation)} \\
    &&&& | & ~ \meme ~ (e, e) &\quad\text{(Membership)} \\
    &&&& | & ~ \lene ~ e &\quad\text{(Length)} \\
    &&&& | & ~ \tupe ~ \seq e &\quad\text{(Tuple)} \\
    &&&& | & ~ \casee ~ (s, \seq e) &\quad\text{(Tagged Tuple)} \\
    &&&& | & ~ \itere ~ (e, iter, \seq{s}) &\quad\text{(Iteration)} \\
    &&&& | & ~ \liste ~ \seq e &\quad\text{(List)} \\
    &&&& | & ~ \getcurctxe ~ s &\quad\text{(Get Current Context)} \\
    &&&& | & ~ \choosee ~ e &\quad\text{(Choose)} \\
    &&&& | & ~ \iscaseofe ~ (e, s) &\quad\text{(Check Tag)} \\
    &&&& | & ~ \ctxkinde ~ s &\quad\text{(Context Kind)} \\
    &&&& | & ~ \matche ~ (e, e) &\quad\text{(Match)} \\
    &&&& | & ~ \hastypee ~ (e, s) &\quad\text{(Has Type)} \\
%
% Operator
  \text{Unary Operator}\quad& Unop &\ni& unop &::=& ~ \notop ~ | ~ \minusop \\
  \text{Binary Operator}\quad& Binop &\ni& binop &::=& ~ \addop &\quad\text{(Addition)} \\
    &&&& | & ~ \subop &\quad\text{(Subtraction)} \\
    &&&& | & ~ \mulop &\quad\text{(Multiplication)} \\
    &&&& | & ~ \divop &\quad\text{(Division)} \\
    &&&& | & ~ \modop &\quad\text{(Modular)} \\
    &&&& | & ~ \expop &\quad\text{(Exponential)} \\
    &&&& | & ~ \implop &\quad\text{(Implication)} \\
    &&&& | & ~ \equivop &\quad\text{(Equivalence)} \\
    &&&& | & ~ \andop &\quad\text{(And)} \\
    &&&& | & ~ \orop &\quad\text{(Or)} \\
    &&&& | & ~ \eqop &\quad\text{(Equal)} \\
    &&&& | & ~ \neop &\quad\text{(Not Equal)} \\
    &&&& | & ~ \ltop &\quad\text{(Less Than)} \\
    &&&& | & ~ \gtop &\quad\text{(Greater Than)} \\
    &&&& | & ~ \leop &\quad\text{(Less or Equal)} \\
    &&&& | & ~ \geop &\quad\text{(Greater or Equal)} \\
\end{array}
\end{align*}
\newpage
\begin{align*}
\begin{array}{lcccrlr}
%
% Path
  \text{Path}\quad& P &\ni& p &::=& ~ \idxp ~ e ~ | ~ \slicep ~ (e, e) ~ | ~ \dotp ~ s \\
%
% Iter
  \text{Iter}\quad& Iter &\ni& iter &::=& ~ \listiter ~ | ~ \listniter ~ e ~|~ \listidxiter ~ (s, e) \\
%
% Value
  \text{Value}\quad& V &\ni& v &::=& ~ \numv ~ n &\quad\text{(Number)} \\
    &&&& | & ~ \boolv ~ b &\quad\text{(Boolean)} \\
    &&&& | & ~ \fnamev ~ s &\quad\text{(Function Name)} \\
    &&&& | & ~ \listv ~ \seq v &\quad\text{(List)} \\
    &&&& | & ~ \strv ~ \seq{(s, v)} &\quad\text{(Record)} \\
    &&&& | & ~ \tupv ~ \seq v &\quad\text{(Tuple)} \\
    &&&& | & ~ \casev ~ (s, \seq v) &\quad\text{(Tagged Tuple)} \\
    &&&& | & ~ \trapv &\quad\text{(Trap)} \\
    &&&& | & ~ \storev &\quad\text{(Store)} \\
% Primitives
  \text{String}\quad& \mathbb S &\ni& s \\
  \text{Integer}\quad& \mathbb Z &\ni& n \\
  \text{Boolean}\quad& \mathbb B &\ni& b \\
\end{array}
\end{align*}

% state
An AL state consists of sequence of algorithm, a WebAssembly state, and a
continuation.
% algorithm
An algorithm is either a relation or a function that repectively correspond to
the relation definition and the function definition in the DSL.
Both of them consist of name, parameters, and AL instructions, but has distinct
usage.
% WebAssembly state
WebAssembly state consists of a WebAssembly value stack, an WebAssembly
instruction stack, and a store.
% WebAssembly value & instruction
A WebAssembly value and a WebAssembly instruction are expressed in values,
especially in the form of $\casev$.
% store
A store is expressed in a sequence of a field name and an AL value pairs which
models records.
% continuation
A continuation is empty; let call with a variable, a function name, arguments,
and a continuation; wasm with contexts and a continuation; execute with a
WebAssembly instruction and a continuation; algorithm with AL instructions, an
environment, contexts, and a continuation; or return with a AL value and a
continuation.
% env
A environment is a finite mapping from a variable name to the AL value.
% context
A context is a AL value, especially in the form of $\casev$.
% instruction
An instruction is if, nondeterministically choosing either branch, entering a
block, pusing a context, pushing a value, popping a context, popping a value,
popping n values, popping all the values within a context, let binding,
traping, returing an AL relation, returing an AL function, executing WebAsembly
instruction, executing WebAssembly instruction sequence, AL function call with
let binding, or replacing some mutable data structure.
% expression
An expression is variable, number, boolean, function name, unary operation,
binary operation, access elements of an data structure, update elements of an
data structure, record (or struct), record composition, list concatenation,
membership checking, getting length, tuple, tagged tuple, iteration, list,
getting current context, choosing an element from an data structure, tag
checking, checking context kind, match relation, or type relation.
% value
A value is number, boolean, function name, list, record, tuple, tagged tuple,
trap, or store.


% terminology
State, value, function, and instruction exist in both WebAssembly and AL. In
this section, we abbreviate AL-specific terms (AL state, AL value, AL function
and AL instruction) as simply state, value, function, and instruction, while
keeping the WebAssembly terms unchanged.





%% Syntax
\section{Semantics of AL}
\label{semantics}

%% Continuation

\begin{gather*}
\leadsto \subseteq S \times S
\newline \\
%
% TopLevelCall
\newline \\
  \fun ~ (str_1, \seq e, \seq i) = \lookup(\seq{a}, str_1) \quad \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
  \hline
  (\seq{a}, w, \toplevelcall ~ (str_1, \seq v)) \leadsto (\seq{a}, w, \algo ~ (\seq i, \mu, \epsilon, \mt)) \\
%
% Call
\newline \\
  \fun ~ (str_1, \seq e, \seq i) = \lookup(\seq{a}, str_1) \quad \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
  \hline
  (\seq{a}, w, \call ~ (str_0, str_1, \seq v, k)) \leadsto (\seq{a}, w, \algo ~ (\seq i, \mu, \epsilon, \call ~ (str_0, str_1, \seq v, k))) \\
%
% Wasm-zero
\newline \\
  \hline
  (\seq{a}, w, \wasm ~ (\epsilon, k)) \leadsto (\seq{a}, w, k) \\
%
% Wasm-instr
\newline \\
  |\seq c| > 0 \quad
  \casev ~ (str, \seq v) = wi \quad
  \rel ~ (str, \seq e, \seq i) = \lookup(\seq{a}, str) \quad
  \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
  \hline
  (\seq{a}, (wi ~ \seq{wi'}, \seq{wv}, sto), \wasm ~ (\seq c, k))
  \leadsto
  (\seq{a}, (\seq{wi'}, \seq{wv}, sto), \algo ~ (\seq i, \mu, \epsilon, \wasm ~ (\seq c, k))) \\
%
% Execute-instr
\newline \\
  \casev ~ (str, \seq v) = wi \quad
  \rel ~ (str, \seq e, \seq i) = \lookup(\seq{a}, str) \quad
  \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
  \hline
  (\seq{a}, w, \exe ~ (wi', k)) \leadsto (\seq{a}, w, \algo ~ (\seq i, \mu, \epsilon, k)) \\
%
% Al-empty
\newline \\
  \hline
  (\seq{a}, w, \algo ~ (\epsilon, \mu, \seq c, k)) \leadsto (\seq{a}, w, k) \\
%
% Al-instr
\newline \\
  \seq{a}, w, \algo ~ (\seq{i_1}, \mu, \seq c, k) \vdash i_0 \Rightarrow (w', k') \\
  \hline
  (\seq{a}, w, \algo ~ (i_0 ~ \seq{i_1}, \mu, \seq c, k)) \leadsto (\seq{a}, w', k') \\
%
% Return
\newline \\
  \mu = \getenv(k) \quad k' = \setenv(k, \mu[str_0 \mapsto v]) \\
  \hline
  (\seq{a}, w, \ret ~ (v, \call ~ (str_0, str_1, \seq v, k)) \leadsto k' \\
\end{gather*}

The semantics of an AL is defined with a state transition system.
% CallTopLevel
Given the algorithms $\seq a$ generated from the DSL and WebAssembly state $w$,
a top-level function $str$ can be invoked with arguments $\seq v$ to perform
either module instantiation or function invocation:
$(\seq a, w, \toplevelcall ~ (str, \seq v))$.
The contination changes to \algo{} with the function body instructions.
% Call
Similarly, the continuation changes to \call{} upon encountering a call
instruction, and then further moves to \algo{}.
% Wasm
In the \wasm{} continuation, triggered by the enter instruction, the top
WebAssembly instruction is popped from the instruction stack and executed
until the context sequence $\seq c$ is exhausted.
Execution involves looking up the corresponding relation definition and
changing the continuation to \algo{} with the body of that relation.
% Execute
The \execute{} continuation, introduced by the execute instruction, also
processes WebAssembly instructions, changing the continuation to \algo{}.
% Algo
In the \algo{} continuation, the body instructions are executed sequentially.
The semantics of each instruction will be detailed separately.
% Return
The execution of a function call concludes with a return instruction, shifting
the continuation to \ret{}.
If the function call originates from a \call{}, the result is assigned to a
variable.
If it originates from a \toplevelcall{}, the entire execution completes:
$
(\seq a, w, \toplevelcall ~ (str, \seq v))
\leadsto^*
(\seq a, w', \ret ~ (v', \mt))
$.


%% Instruction

\begin{gather*}
  \text{NOTE: input cont is always \algo} \\
  \seq{a}, ~ w, ~ k \vdash i \Rightarrow w, ~ k \\
%
% If-true
\newline \\
  \mu = \getenv(k) \quad w, \mu \vdash e \Rightarrow v \quad
  \istrue(v) \quad k' = \prependinstr(k, \seq{i_1}) \\
  \hline
  \seq{a}, w, k \vdash \ifi ~ (e, \seq{i_1}, \seq{i_2}) \Rightarrow (w, k') \\
%
% If-false
\newline \\
  \mu = \getenv(k) \quad w, \mu \vdash e \Rightarrow v \quad
  \neg \istrue(v) \quad k' = \prependinstr(k, \seq{i_2}) \\
  \hline
  \seq{a}, w, k \vdash \ifi ~ (e, \seq{i_1}, \seq{i_2}) \Rightarrow (w, k') \\
%
% Either-1
\newline \\
  \hline
  \seq{a}, w, k \vdash \eitheri ~ (\seq{i_1}, \seq{i_2}) \Rightarrow (w, \prependinstr(k, \seq{i_1})) \\
%
% Either-2
\newline \\
  \hline
  \seq{a}, w, k \vdash \eitheri ~ (\seq{i_1}, \seq{i_2}) \Rightarrow (w, \prependinstr(k, \seq{i_2})) \\
%
% Enter
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_1 \Rightarrow v_1 \quad
  w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \seq c = \getctx(k) \quad
  \seq{wi_{end}} = [ ~ \getendalgo(c) ~ | ~ c \leftarrow \seq c ~ ] \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), k \vdash \enteri ~ (e_1, e_2)
  \Rightarrow
  ((v_1 ~ \seq{wv}, \seq{v_2} ~ \seq{wi_{end}}~ \seq{wi}, sto), \wasm ~ (v_1 ~ \seq c, \resetctx(k))) \\
%
% PushCtx
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \pushctxi ~ e
  \Rightarrow
  (\push_{WasmValue}(w, v), \addctx(k, v)) \\
%
% Push
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \pushi ~ e \Rightarrow (\push_{WasmValue}(w, v), k) \\
%
% PopCtx
\newline \\
  \mu = \getenv(k) \quad
  wv_{ctx} ~ \seq{wv'} = \exit_{WasmValue}(\seq{wv}) \quad
  \mu' = \assign(\mu, e, wv_{ctx}) \\
  k_1 = \setenv(k, \mu') \quad
  k_2 = \exit_{Cont}(k_1) \quad
  \seq{wi'} = \exit_{WasmInstr}(\seq{wi}) \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), k \vdash \popctxi ~ e
  \Rightarrow
  ((\seq{wv'}, \seq{wi'}, sto), k_2) \\
%
% Pop
\newline \\
  \mu = \getenv(k) \quad
  wv, w' = \pop_{WasmValue}(w) \quad
  \mu' = \assign(\mu, e, wv) \\
  \hline
  \seq{a}, w, k \vdash \popi ~ e \Rightarrow (w', \setenv(k, \mu')) \\
%
% PopN
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \quad
  wv^n, w' = \popn_{WasmValue}(w, n) \quad
  \mu' = \assign(\mu, e_1, \listv ~ wv^n) \\
  \hline
  \seq{a}, w, k \vdash \popni ~ (e_1, e_2) \Rightarrow (w', \setenv(k, \mu')) \\
%
% PopAll
\newline \\
  \mu = \getenv(k) \quad
  \seq{wv_0}, \seq{wv_1} = \splitctx(wv) \quad
  \mu' = \assign(\mu, e, \listv ~ \seq{wv_0}) \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), e \vdash \popalli ~ e
  \Rightarrow
  ((\seq{wv_1}, \seq{wi}, sto), \setenv(k, \mu')) \\
%
% Let
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_2 \Rightarrow v \quad
  \mu' = \assign(\mu, e_1, v) \\
  \hline
  \seq{a}, w, k \vdash \leti ~ (e_1, e_2)
  \Rightarrow
  (w, \setenv(k, \mu')) \\
%
% Trap
\newline \\
  \hline
  \seq{a}, w, k \vdash \trapi \Rightarrow (w, \ret ~ (\trapv, \mt)) \\
%
% Return-rule
\newline \\
  \hline
  \seq{a}, w, \algo~ (\seq{i}, \mu, \seq c, k) \vdash \returnrulei \Rightarrow (w, k) \\
%
% Return-func
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, \algo ~ (\seq{i}, \mu, \seq c, k) \vdash \returnfunci ~ e \Rightarrow (w, \ret ~ (v, k)) \\
%
% Execute
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \executei ~ e \Rightarrow (w, \exe ~ (v, k)) \\
%
% ExecuteSeq
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e \Rightarrow \listv ~ \seq v \quad
  k' = \fold(\execute, \seq v, k) \\
  \hline
  \seq{a}, w, k \vdash \executeseqi ~ e \Rightarrow (w, k') \\
%
% Call-fname
\newline \\
  \mu = \getenv(k) \quad
  \fnamev ~ str_2 = \mu(str_1) \quad
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  \seq{a}, w, k \vdash \calli ~ (str_0, str_1, \seq e) \Rightarrow (w, \call ~ (str_0, str_2, \seq v, k)) \\
%
% Call-fname
\newline \\
  \mu = \getenv(k) \quad
  str_1 \not\in \domain(\mu) \quad
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  \seq{a}, w, k \vdash \calli ~ (str_0, str_1, \seq e) \Rightarrow (w, \call ~ (str_0, str_1, \seq v, k)) \\
%
% Replace-frame
\newline \\
\text{NOTE: $e_1$ is either store or current frame} \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_1 \Rightarrow v_1 \quad
  \isframe(v_1) \quad
  w, \mu \vdash e_2 \Rightarrow v_2 \quad
  v_3 = \update(v_1, \seq p, v_2) \\
  \hline
  \seq{a}, w, k \vdash \replacei ~ (e_1, \seq{path}, e_2) \Rightarrow (\setcurframe(w, v_3), k) \\
%
% Replace-store
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_1 \Rightarrow \storev \quad
  w, \mu \vdash e_2 \Rightarrow v_2 \quad
  sto' = \update(\strv sto, \seq p, v_2) \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), k \vdash \replacei ~ (e_1, \seq{path}, e_2)
  \Rightarrow ((\seq{wv}, \seq{wi}, sto'), k) \\
\end{gather*}





%% Expression

\begin{gather*}
  w, \mu \vdash e \Rightarrow v
%
% Var
\newline \\
  v = \mu(str) \\
  \hline
  w, \mu \vdash \vare ~ str \Rightarrow v \\
%
% Num
\newline \\
  \hline
  w, \mu \vdash \nume ~ n \Rightarrow \numv ~ n \\
%
% Bool
\newline \\
  \hline
  w, \mu \vdash \boole ~ b \Rightarrow \boolv ~ b \\
%
% Fname
\newline \\
  \hline
  w, \mu \vdash \fnamee ~ str \Rightarrow \fnamev ~ str \\
%
% Un
\newline \\
  w, \mu e \Rightarrow v \\
  \hline
  w, \mu \vdash \une ~ (unop, e) \Rightarrow \unop(unop, v) \\
%
% Bin
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \bine ~ (binop, e_1, e_2) \Rightarrow \binop(binop, v_1, v_2) \\
%
% Acc
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \acce ~ (e, path) \Rightarrow \access(w, \mu, v, path) \\
%
% Upd
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \upde ~ (e_1, \seq path, e_2) \Rightarrow \update(v_1, \seq path, v_2) \\
%
% Str
\newline \\
  \seq{(str, v)} =
    [ ~
      str, v
    ~ | ~
      (str, e) \leftarrow \seq{(str, e)}; w, \mu \vdash e \Rightarrow v
    ~ ] \\
  \hline
  w, \mu \vdash \stre ~ \seq{(str, e)} \Rightarrow \strv ~ \seq{(str, v)} \\
%
% Comp
\newline \\
   w, \mu \vdash e_1 \Rightarrow \strv ~ \seq{(str_1, v_1)} \quad
   w, \mu \vdash e_2 \Rightarrow \strv ~ \seq{(str_2, v_2)} \\
  \hline
  w, \mu \vdash \compe ~ (e_1, e_2) \Rightarrow \strv ~ (\seq{(str_1, v_1)} ~ \seq{(str_2, v_2)}) \\
%
% Cat
\newline \\
   w, \mu \vdash e_1 \Rightarrow \listv ~ \seq{v_1} \quad
   w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \hline
  w, \mu \vdash \cate ~ (e_1, e_2) \Rightarrow \listv ~ (\seq{v_1} ~ \seq{v_1}) \\
%
% Mem
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad
  w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \hline
  w, \mu \vdash \meme ~ (e_1, e_2) \Rightarrow \boolv ~ (v_1 \in \seq{v_2}) \\
%
% Len
\newline \\
  w, \mu \vdash e \Rightarrow \listv ~ \seq{v} \\
  \hline
  w, \mu \vdash \lene ~ e \Rightarrow \numv ~ |\seq v| \\
%
% Tup
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \tupe ~ \seq{e} \Rightarrow \tupv ~ \seq{v} \\
%
% Case
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \casee ~ (str, \seq{e}) \Rightarrow \casev ~ (str, \seq{v}) \\
%
% Iter-
\newline \\
  f =
    (\lambda ~ str ~ acc. ~
      \listv ~ \seq v = \mu(str); ~
      [ ~ \mu_1[str \mapsto v] ~ | ~ (v, \mu_1) \leftarrow \zip (\seq v, acc) ~ ]
    )
  \\
  \seq{\mu_2} = \fold(f, \seq{str}, \duplicateenv(\mu, \seq{str})) \quad
  \seq{v'} =
    [ ~
      v'
    ~ | ~
      \mu_3 \leftarrow \seq {\mu_2}; ~ w, \mu_3 \vdash e \Rightarrow v'
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e, \listiter, \seq{str}) \Rightarrow \listv ~ \seq{v'} \\
%
% Iter-n
\newline \\
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \\
  f_i =
    (\lambda ~ x ~ acc. ~
      \listv ~ \seq v = \mu(x); ~
      [ ~ \mu_1[str \mapsto v] ~ | ~ (v, \mu_1) \leftarrow \zip (\seq v, acc) ~ ]
    )
  \\
  \seq{\mu_2} = \fold(f, \seq{str}, \mu^n) \quad
  \seq{v'} =
    [ ~
      v'
    ~ | ~
      \mu_3 \leftarrow \seq {\mu_2}; ~ w, \mu_3 \vdash e_1 \Rightarrow v'
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listniter ~ e_2, \seq{str}) \Rightarrow \listv ~ \seq{v'} \\
%
% Iter-idx
\newline \\
  \seq{\mu_1} =
    [ ~
      \fold(
        (\lambda ~ x ~ acc. ~ acc[x \mapsto \numv ~ i]),
        \seq{str},
        \mu
      )
    ~ | ~
      i \leftarrow [0 ~ .. ~ n-1]
    ~ ]
  \quad
  \seq{v'} =
    [ ~
      v'
    ~ | ~
      \mu_2 \leftarrow \seq {\mu_1}; ~ w, \mu_2 \vdash e_1 \Rightarrow v'
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listidxiter ~ e_2, \seq{str}) \Rightarrow \listv ~ \seq{v'} \\
%
% List
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \liste ~ \seq{e} \Rightarrow \listv ~ \seq{v} \\
%
% GetCurCtx
\newline \\
  v_{ctx} = \getcurctx(w, str) \\
  \hline
  w, \mu \vdash \getcurctxe ~ str \Rightarrow v_{ctx} \\
%
% Choose
\newline \\
  w, \mu \vdash e \Rightarrow \listv ~ \seq{v} \quad
  v' \in \seq{v} \\
  \hline
  w, \mu \vdash \choosee ~ e \Rightarrow v' \\
%
% IsCaseOf
\newline \\
  w, \mu \vdash e \Rightarrow \casev ~ (str', \seq{v}) \\
  \hline
  w, \mu \vdash \iscaseofe ~ (e, str) \Rightarrow \boolv ~ (str = str') \\
%
% IsValid
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \isvalide ~ e \Rightarrow \boolv ~ (\isvalid(v)) \\
%
% CtxKind
\newline \\
  \casev (str', \seq v) = \getcurctx(w, str) \\
  \hline
  w, \mu \vdash \ctxkinde ~ str \Rightarrow \boolv ~ (str = str') \\
%
% Match
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad
  w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \matche ~ (e_1, e_2) \Rightarrow \boolv ~ (\match(v_1, v_2)) \\
%
% HasType
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \hastypee ~ (e, str) \Rightarrow \boolv ~ (\hastype(v, str)) \\
\end{gather*}




%% Helper functions

\begin{align*}
%
% get_algo_name
\newline \\
  &\getalgoname(\rel ~ (str, \seq e, \seq i)) = str \\
  &\getalgoname(\fun ~ (str, \seq e, \seq i)) = str \\
%
% lookup
\newline \\
  &str = \getalgoname(a) \\
  \hline
  &\lookup(a ~ \seq{a'}, str) = a \\
%
  &str \not = \getalgoname(a) \\
  \hline
  &\lookup(a ~ \seq{a'}, str) = \lookup(\seq{a'}, str) \\
%
% pop_all-ctx
\newline \\
&\text{NOTE: an input of is\_ctx (WasmValue sequence) contains at least one context} \\
  &\text{is\_ctx}(\text{hd}(\seq{wv})) \\
  \hline
  &\splitctx(\seq{wv}) = \epsilon, \seq{wv} \\
% pop_all-val
  &\text{is\_not\_ctx}(wv_0) \quad \seq{wv_2}, \seq{wv_3} = \splitctx(\seq{wv_1}) \\
  \hline
  &\splitctx(wv_0 ~ \seq{wv_1}) = wv_0 ~ \seq{wv_2}, \seq{wv_3} \\
%
% execute
\newline \\
  &\execute(v, k) = \exe(v, k) \\
%
% exit_cont-wasm_0
\newline \\
&\text{NOTE: input cont of exit is either \algo ~ or \wasm} \\
  &\exit_{Cont}(\wasm (\epsilon, k)) = \wasm(\epsilon, \exit_{Cont}(k)) \\
% exit_cont-wasm_nonzero
  &\exit_{Cont}(\wasm (c ~ \seq{c'}, k)) = \wasm(\seq{c'}, k) \\
% exit_cont-al
  &\exit_{Cont}(\algo (\seq i, \mu, \seq c, k)) = \algo (\seq i, \mu, \seq c, \exit(k)) \\
%
% exit_wasm_instr-end
\newline \\
  &\text{is\_end}(wi) \\
  \hline
  &\exit_{WasmInstr}(wi ~ \seq{wi'}) = \seq{wi'} \\
% exit_wasm_instr-normal_instr
  &\text{is\_not\_end}(wi) \\
  \hline
  &\exit_{WasmInstr}(wi ~ \seq{wi'}) = \exit_{WasmInstr}(\seq{wi'}) \\
%
% exit_wasm_value
  &\seq{wv_1}, \seq{wv_2} = \splitctx(\seq{wv_0}) \\
  \hline
  &\exit_{WasmValue}(\seq{wv_0}) = \seq{wv_2} \\
%
% duplicate_env-empty
\newline \\
  &\duplicateenv(\mu, epsilon) = \mu \\
% duplicate_env-nonempty
  &\listv ~ \seq v = \mu(str) \\
  \hline
  &\duplicateenv(\mu, str ~ \seq{str'}) = \mu^{|\seq v|} \\
%
% get_env
\newline \\
  &\getenv(\algo ~ (\seq i, \mu, \seq c, k)) = \mu \\
%
% set_env
\newline \\
  &\setenv(\algo ~ (\seq i, \mu, \seq c, k), \mu') = \algo ~ (\seq i, \mu', \seq c, k) \\
%
% prepend_instr
\newline \\
  &\prependinstr(\algo ~ (\seq i, \mu, \seq c, k), \seq{i'}) = \algo ~ (\seq{i'} ~ \seq i, \mu, \seq c, k) \\
%
% get_ctx
\newline \\
  &\getctx(\algo ~ (\seq i, \mu, \seq c, k)) = \seq c \\
%
% add_ctx
\newline \\
  &\addctx(\algo ~ (\seq i, \mu, \seq c, k), c') = \algo ~ (\seq i, \mu, c' ~ \seq c, k) \\
%
% reset_ctx
\newline \\
  &\resetctx(\algo ~ (\seq i, \mu, \seq c, k)) = \algo ~ (\seq i, \mu, \epsilon, k) \\
%
% push
\newline \\
  &\push((\seq{wv}, \seq{wi}, sto), wv') = wv' ~ \seq{wv}, \seq{wi}, sto \\
%
% pop
\newline \\
  &\pop((wv ~ \seq{wv'}, \seq{wi}, sto)) = \seq{wv'}, \seq{wi}, sto \\
%
% popn
\newline \\
  &\popn((wv^n ~ \seq{wv'}, \seq{wi}, sto), n) = \seq{wv'}, \seq{wi}, sto \\
%
% unop
\newline \\
  &\istrue(v) \\
  \hline
  &\unop(\notop, v) = \boolv ~ false \\
  &\neg\istrue(v) \\
  \hline
  &\unop(\notop, v) = \boolv ~ true \\
  &\unop(\minusop, \numv ~ n) = \numv ~ (-n) \\
%
% get_cur_ctx
\newline \\
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \\
  \hline
  &\getcurctx((\seq{wv}, \seq{wi}, sto)) = wv_{ctx} \\
%
% get_cur_frame-frame
\newline \\
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \quad \isframe(wv_{ctx}) \\
  \hline
  &\getcurframe((\seq{wv}, \seq{wi}, sto)) = wv_{ctx} \\
% get_cur_frame-other
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \quad \neg \isframe(wv_{ctx}) \\
  \hline
  &\getcurframe((\seq{wv}, \seq{wi}, sto)) = \getcurframe(\seq{wv_2}) \\
%
% set_cur_frame-frame
\newline \\
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \quad \isframe(wv_{ctx}) \\
  \hline
  &\setcurframe((\seq{wv}, \seq{wi}, sto), v_{frame})
  =
  \seq{wv_1} ~ v_{frame} ~ \seq{wv_2}, \seq{wi}, sto \\
% set_cur_frame-other
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \quad \neg \isframe(wv_{ctx}) \\
  \hline
  &\setcurframe((\seq{wv}, \seq{wi}, sto), v_{frame})
  =
  \seq{wv_1} ~ wv_{ctx} ~ \setcurframe(\seq{wv_2}, v_{frame}), \seq{wi}, sto \\
%
% access-idx
\newline \\
  &\numv ~ n = \sem{e}(\mu, w) \quad \listv ~ \seq{v'} = v \\
  \hline
  &\access(\mu, w, v, \idxp ~ e) = \seq{v'}[n] \\
% access-slice
  &\numv ~ n_1 = \sem{e_1}(\mu, w) \quad
  \numv ~ n_2 = \sem{e_2}(\mu, w) \quad
  \listv ~ \seq{v'} = v \\
  \hline
  &\access(\mu, w, v, \slicep ~ (e_1, e_2)) = \seq{v'}[n_1: n_2] \\
% access-dot
  &\strv ~ ((str_0, v_0) ~ \seq{(str_1, v_1)}) = v \quad
  str_0 = str \\
  \hline
  &\access(\mu, w, v, \dotp ~ str) = v_0 \\
  &\strv ~ ((str_0, v_0) ~ \seq{(str_1, v_1)}) = v \quad
  str_0 \not= str \\
  \hline
  &\access(\mu, w, v, \dotp ~ str) = \access(\mu, w, \strv ~ \seq{(str_1, v_1)}, \dotp ~ str) \\
% access-store
  &\storev = v \quad w = (\seq{wv}, \seq{wi}, sto)\\
  \hline
  &\access(\mu, w, v, path)
  =\access(\mu, w, \strv sto, path) \\
%
% update-idx
\newline \\
  &\numv ~ n = \sem{e}(\mu, w) \quad
  \listv ~ \seq{v_3} = v_1 \\
  \hline
  &\update(\mu, w, v_1, (\idxp ~ e) ~ \seq{path}, v_2)
  =
  \updateidx(v_3, n, \update(\mu, w, \seq{v_3}[n], \seq{path}, v_2)) \\
% update_idx
  &\updateidx(v_0 ~ \seq{v_1}, 0, v_2) =  v_2 ~ \seq{v_1} \\
  &n > 0 \\
  \hline
  &\updateidx(v_0 ~ \seq{v_1}, n, v_2) =  v_0 ~ \updateidx(\seq{v_1}, n-1, v_2) \\
%
% update-slice
\newline \\
  &\numv ~ n_1 = \sem{e_1}(\mu, w) \quad
  \numv ~ n_2 = \sem{e_2}(\mu, w) \quad
  \listv ~ \seq{v_3} = v_1 \\
  \hline
  &\update(\mu, w, v_1, (\slicep ~ e) ~ \seq{path}, v_2)
  =
  \updateslice(v_3, n_1, n_2, \update(\mu, w, \seq{v_3}[n_1: n_2], \seq{path}, v_2)) \\
% update_slice
  &\updateslice(v_0^n ~ \seq{v_1}, 0, n, v_2^n) = v_2^n ~ \seq{v_1} \\
  &m > 0 \\
  \hline
  &\updateslice(v_0 ~ \seq{v_1}, m, n, v_2^n) =  v_0 ~ \updateslice(\seq{v_1}, m-1, n, v_2) \\
%
% update-dot
\newline \\
  &\strv ~ \seq{(str', v')} = v \\
  \hline
  &\update(\mu, w, v, (\dotp ~ str) ~ \seq{path}, v_2)
  =
  \updatedot(\seq{(str', v')}, str, \update(\mu, w, \access(v, \dotp ~ str), \seq{path}, v_2)) \\
% update_dot
  &str_0 = str_2 \\
  \hline
  &\updatedot((str_0, v_0) ~ \seq{(str_1, v_1)}, str_2, v_2)
  =
  (str_2, v_2) ~ \seq{(str_1, v_1)} \\
  &str_0 \not= str_2 \\
  \hline
  &\updatedot((str_0, v_0) ~ \seq{(str_1, v_1)}, str_2, v_2)
  =
  (str_0, v_0) ~ \updatedot(\seq{(str_1, v_1)}, str_2, v_2) \\
%
% get_end_algo
\newline \\
  &\getendalgo(\casev(\text{"LABEL"}, \epsilon)) = \casev(\text{"EXTING"}, \epsilon) \\
  &\getendalgo(\casev(\text{"FRAME"}, \epsilon)) = \casev(\text{"RETURNING"}, \epsilon) \\
%
% is_true
\newline \\
  &\istrue(\boolv ~ b) = b \\
  &\istrue(\listv ~ \seq v) = \forall v' \in \seq v. \istrue (v') \\
%
% is_frame
\newline \\
  &\isframe(\casev ~ (\text{"FRAME"}, \seq v)) = true \\
  &otherwise \\
  \hline
  &\isframe(v) = false \\
%
% zip
\newline \\
  &\zip(eps, eps) = eps \\
  &\zip(x ~ \seq{x'}, y ~ \seq{y'}) = (x, y) ~ \zip (\seq{x'}, \seq{y'}) \\
%
% fold
\newline \\
  &\fold(f, x^n, acc) = f(x_0, f(x_1, ~ ... ~ f(x_{n-2}, f(x_{n-1}, acc)) ~ ... ~ ))
\end{align*}





