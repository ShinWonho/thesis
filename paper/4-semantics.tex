% !TEX root = main.tex

\chapter{Semantics}
\label{ch:semantics}
\noindent


% AL semantics formalize
%
%
% Prose notation:
% - Implicit when to exit:
%   • Returning from a function
%     When the end of a function is reached without a jump (i.e., return) or trap aborting it, then the following steps are performed.
%
%   • Exiting with label
%     When the end of a block is reached without a jump or trap aborting it, then the following steps are performed.
%
%   ! end of function/label is defined verbally, not in algorithmic notation
%
% - Separate context and instructions:
%   • Push ctx \& Jump instrs
%
%
% abstract machine of prose notation: vm
% 1. state: stack, store
% 2. cosumes sequence of WebAssembly instruction
% 3. mutate state
%
% - store
%   - instantiate -> alloc
%   - invoke -> use
% - stack contains value \& context
%   - value
%     ex: binop
%   - context
%     1) label: allow structured control flow (continuation)
%     2) frame: store call information (local variable, module instance)
%     - enter \& exit
%     - ex: loop, invoke
%     - ex: br, implicit exit
%
%
% - wrong interpretation of "end" in AL interpreter \red{(How long does it occur?)}
% - example

\red{TODO: update syntax}


\newcommand{\sem}[1]{[\![#1]\!]}
\newcommand{\seq}[1]{#1^*}



%% Symbol definition

\renewcommand{\symbol}[1]{\textbf{#1}}

% Continuation
\newcommand{\mt}{\symbol{Empty}}
\newcommand{\call}{\symbol{Call}}
\newcommand{\algo}{\symbol{Algo}}
\newcommand{\enter}{\symbol{Enter}}
\newcommand{\wasm}{\symbol{Wasm}}
\newcommand{\exe}{\symbol{Execute}}
\newcommand{\ret}{\symbol{Return}}

% Instruction
\newcommand{\ifi}{\symbol{IfI}}
\newcommand{\eitheri}{\symbol{EitherI}}
\newcommand{\enteri}{\symbol{EnterI}}
\newcommand{\pushctxi}{\symbol{PushCtxI}}
\newcommand{\pushi}{\symbol{PushI}}
\newcommand{\popctxi}{\symbol{PopCtxI}}
\newcommand{\popi}{\symbol{PopI}}
\newcommand{\popni}{\symbol{PopNI}}
\newcommand{\popalli}{\symbol{PopAllI}}
\newcommand{\leti}{\symbol{LetI}}
\newcommand{\trapi}{\symbol{TrapI}}
\newcommand{\nopi}{\symbol{NopI}}
\newcommand{\returnrulei}{\symbol{ReturnRuleI}}
\newcommand{\returnfunci}{\symbol{ReturnFuncI}}
\newcommand{\executei}{\symbol{ExecuteI}}
\newcommand{\executeseqi}{\symbol{ExecuteSeqI}}
\newcommand{\calli}{\symbol{CallI}}
\newcommand{\replacei}{\symbol{ReplaceI}}

% Expression
\newcommand{\vare}{\symbol{VarE}}
\newcommand{\nume}{\symbol{NumE}}
\newcommand{\boole}{\symbol{BoolE}}
\newcommand{\fnamee}{\symbol{FnameE}}
\newcommand{\une}{\symbol{UnE}}
\newcommand{\bine}{\symbol{BinE}}
\newcommand{\acce}{\symbol{AccE}}
\newcommand{\upde}{\symbol{UpdE}}
\newcommand{\stre}{\symbol{StrE}}
\newcommand{\compe}{\symbol{CompE}}
\newcommand{\cate}{\symbol{CatE}}
\newcommand{\meme}{\symbol{MemE}}
\newcommand{\lene}{\symbol{LenE}}
\newcommand{\tupe}{\symbol{TupE}}
\newcommand{\casee}{\symbol{CaseE}}
\newcommand{\itere}{\symbol{IterE}}
\newcommand{\liste}{\symbol{ListE}}
\newcommand{\getcurctxe}{\symbol{GetCurContextE}}
\newcommand{\choosee}{\symbol{ChooseE}}
\newcommand{\iscaseofe}{\symbol{IsCaseOfE}}
\newcommand{\isvalide}{\symbol{IsValidE}}
\newcommand{\ctxkinde}{\symbol{CtxKindE}}
\newcommand{\matche}{\symbol{MatchE}}
\newcommand{\hastypee}{\symbol{HasTypeE}}

% Unary operator
\newcommand{\notop}{\symbol{NotOp}}
\newcommand{\minusop}{\symbol{MinusOp}}

% Binary operator
\newcommand{\addop}{\symbol{AddOp}}
\newcommand{\subop}{\symbol{SubOp}}
\newcommand{\mulop}{\symbol{MulOp}}
\newcommand{\divop}{\symbol{DivOp}}
\newcommand{\modop}{\symbol{ModOp}}
\newcommand{\expop}{\symbol{ExpOp}}
\newcommand{\implop}{\symbol{ImplOp}}
\newcommand{\equivop}{\symbol{EquivOp}}
\newcommand{\andop}{\symbol{AndOp}}
\newcommand{\orop}{\symbol{OrOp}}
\newcommand{\eqop}{\symbol{EqOp}}
\newcommand{\neop}{\symbol{NeOp}}
\newcommand{\ltop}{\symbol{LtOp}}
\newcommand{\gtop}{\symbol{GtOp}}
\newcommand{\leop}{\symbol{LeOp}}
\newcommand{\geop}{\symbol{GeOp}}

% Path
\newcommand{\idxp}{\symbol{Idx}}
\newcommand{\slicep}{\symbol{Slice}}
\newcommand{\dotp}{\symbol{Dot}}

% Iter
\newcommand{\listiter}{\symbol{List}}
\newcommand{\listniter}{\symbol{ListN}}
\newcommand{\listidxiter}{\symbol{Index}}

% Value
\newcommand{\numv}{\symbol{NumV}}
\newcommand{\boolv}{\symbol{BoolV}}
\newcommand{\listv}{\symbol{ListV}}
\newcommand{\strv}{\symbol{StrV}}
\newcommand{\casev}{\symbol{CaseV}}
\newcommand{\tupv}{\symbol{TupV}}
\newcommand{\fnamev}{\symbol{FnameV}}
\newcommand{\trapv}{\symbol{TrapV}}
\newcommand{\storev}{\symbol{StoreV}}




%% Helper function

\newcommand{\helper}[1]{\text{#1}}

% Helper function
\newcommand{\lookup}{\helper{lookup}}
\newcommand{\execute}{\helper{execute}}
\newcommand{\exit}{\helper{exit}}
\newcommand{\duplicateenv}{\helper{duplicate\_env}}
\newcommand{\getctx}{\helper{get\_ctx}}
\newcommand{\addctx}{\helper{add\_ctx}}
\newcommand{\resetctx}{\helper{reset\_ctx}}
\newcommand{\getenv}{\helper{get\_env}}
\newcommand{\setenv}{\helper{set\_env}}
\newcommand{\prependinstr}{\helper{prepend\_instr}}
\newcommand{\push}{\helper{push}}
\newcommand{\pop}{\helper{pop}}
\newcommand{\popn}{\helper{popn}}
\newcommand{\unop}{\helper{unop}}
\newcommand{\splitctx}{\helper{split\_ctx}}
\newcommand{\getcurctx}{\helper{get\_cur\_ctx}}
\newcommand{\getcurframe}{\helper{get\_cur\_frame}}
\newcommand{\setcurframe}{\helper{set\_cur\_frame}}
\newcommand{\access}{\helper{access}}
\newcommand{\update}{\helper{update}}
\newcommand{\updateidx}{\helper{update\_idx}}
\newcommand{\updateslice}{\helper{update\_slice}}
\newcommand{\updatedot}{\helper{update\_dot}}
\newcommand{\getendalgo}{\helper{get\_end\_algo}}
\newcommand{\istrue}{\helper{is\_true}}
\newcommand{\isframe}{\helper{is\_frame}}
\newcommand{\zip}{\helper{zip}}
\newcommand{\fold}{\helper{fold}}
% How to express?
\newcommand{\domain}{\helper{domain}}
% Hardcode
\newcommand{\assign}{\helper{assign}}
\newcommand{\iswasmvalueinstr}{\helper{is\_wasm\_value\_instr}}
\newcommand{\binop}{\helper{binop}}
% Reference interpreter
\newcommand{\isvalid}{\helper{is\_valid}}
\newcommand{\match}{\helper{match}}
\newcommand{\hastype}{\helper{has\_type}}




%% Syntax
\section{Syntax of AL}
\label{syntax}

\begin{align*}
%
% State
  s \in S =& \seq A \times W \times Cont \\
%
% Algorithm
  a \in A =& str \times \seq E \times \seq I \\
%
% Wasm state
  w \in W =& \seq{WasmValue} \times \seq{WasmInstr} \times Store \\
  wv \in WasmValue =& V \\
  wi \in WasmInstr =& V \\
%
% Store
  sto \in Store =& String \mapsto \seq V \\
%
% Continuation
  k \in Cont =& ~ \mt \\
    | & ~ \call ~ String \times \seq V \times Cont \\
    | & ~ \algo ~ \seq I \times Env \times \seq C \times Cont \\
    | & ~ \wasm ~ \seq C \times Cont \\
    | & ~ \exe ~ wi \times Cont \\
    | & ~ \ret ~ V \times Cont \\
%
% Environment
  \mu \in Env =& String \mapsto V \\
%
% Control
  c \in C =& V \\
%
% Instruction
  i \in I =& ~ \ifi ~ E \times \seq I \times \seq I \\
    | & ~ \eitheri ~ \seq I \times \seq I \\
    | & ~ \enteri ~ E \times E \\
    | & ~ \pushctxi ~ E \\
    | & ~ \pushi ~ E \\
    | & ~ \popctxi ~ E \\
    | & ~ \popi ~ E \\
    | & ~ \popni ~ E \times E \\
    | & ~ \popalli ~ E \\
    | & ~ \leti ~ E \times E \\
    | & ~ \trapi \\
    | & ~ \returnrulei \\
    | & ~ \returnfunci ~ E \\
    | & ~ \executei ~ E \\
    | & ~ \executeseqi ~ E \\
    | & ~ \calli ~ String \times String \times \seq{E} \\
    | & ~ \replacei ~ E \times \seq{Path} \times E \\
%
% Expression
  e \in E =& ~ \vare ~ String \\
    | & ~ \nume ~ \mathbb N \\
    | & ~ \boole ~ \mathbb B \\
    | & ~ \fnamee ~ String \\
    | & ~ \une ~ Unop \times E \\
    | & ~ \bine ~ Binop \times E \times E \\
    | & ~ \acce ~ E \times Path \\
    | & ~ \upde ~ E \times \seq Path \times E \\
    | & ~ \stre ~ \seq{(String \times E)} \\
    | & ~ \compe ~ E \times E \\
    | & ~ \cate ~ E \times E \\
    | & ~ \meme ~ E \times E \\
    | & ~ \lene ~ E \\
    | & ~ \tupe ~ \seq E \\
    | & ~ \casee ~ String \times \seq E \\
    | & ~ \itere ~ E \times Iter \times \seq{String} \\
    | & ~ \liste ~ \seq E \\
    | & ~ \getcurctxe ~ String \\
    | & ~ \choosee ~ E \\
    | & ~ \iscaseofe ~ E \times String \\
    | & ~ \ctxkinde ~ String \\
    | & ~ \matche ~ E \times E \\
    | & ~ \hastypee ~ E \times String \\
%
% Operator
  unop \in Unop =& ~ \notop ~ | ~ \minusop \\
  binop \in Binop =& ~ \addop \\
    | & ~ \subop \\
    | & ~ \mulop \\
    | & ~ \divop \\
    | & ~ \modop \\
    | & ~ \expop \\
    | & ~ \implop \\
    | & ~ \equivop \\
    | & ~ \andop \\
    | & ~ \orop \\
    | & ~ \eqop \\
    | & ~ \neop \\
    | & ~ \ltop \\
    | & ~ \gtop \\
    | & ~ \leop \\
    | & ~ \geop \\
%
% Path
  path \in Path =& ~ \idxp ~ E ~ | ~ \slicep ~ E \times E ~ | ~ \dotp ~ String \\
%
% Iter
  iter \in Iter =& ~ \listiter ~ | ~ \listniter ~ E ~|~ \listidxiter ~ String \times E \\
%
% Value
  v \in V =& ~ \numv ~ \mathbb N \\
    | & ~ \boolv ~ \mathbb B \\
    | & ~ \listv ~ \seq V \\
    | & ~ \strv ~ \seq{(String \times V)} \\
    | & ~ \casev ~ String \times \seq V \\
    | & ~ \tupv ~ \seq V \\
    | & ~ \fnamev ~ String \\
    | & ~ \trapv \\
    | & ~ \storev \\
\end{align*}



%% Syntax
\section{Semantics of AL}
\label{semantics}

%% Continuation

\begin{gather*}
\newline \\
  S \leadsto S
%
% Call
\newline \\
  \seq e, \seq i = \lookup(\seq{a}, str_1) \quad \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
  \hline
  (\seq{a}, w, \call ~ (str_0, str_1, \seq v, k)) \leadsto (\seq{a}, w, \algo ~ (\seq i, \mu, \epsilon, \call ~ (str_0, str_1, \seq v, k))) \\
%
% Return
  \mu = \getenv(k) \quad k' = \setenv(k, \mu[str_0 \mapsto v]) \\
  \hline
  (\seq{a}, w, \ret ~ (v, \call ~ (str_0, str_1, \seq v, k)) \leadsto k' \\
%
% Al-empty
\newline \\
  \hline
  (\seq{a}, w, \algo ~ (\epsilon, \mu, \seq c, k)) \leadsto (\seq{a}, w, k) \\
%
% Al-instr
\newline \\
  \seq{a}, w, \algo ~ (\seq{i_1}, \mu, \seq c, k) \vdash i_0 \Rightarrow (w', k') \\
  \hline
  (\seq{a}, w, \algo ~ (i_0 ~ \seq{i_1}, \mu, \seq c, k)) \leadsto (\seq{a}, w', k') \\
%
% Wasm-zero
\newline \\
  \hline
  (\seq{a}, w, \wasm ~ (\epsilon, k)) \leadsto (\seq{a}, w, k) \\
%
% Wasm-value
\newline \\
  |\seq c| > 0 \quad \iswasmvalueinstr(wi) \\
  \hline
  (\seq{a}, (wi ~ \seq{wi'}, \seq{wv}, sto), \wasm ~ (\seq c, k))
  \leadsto
  (\seq{a}, (\seq{wi'}, wi ~ \seq{wv}, sto), \wasm ~ (\seq c, k)) \\
%
% Wasm-instr
\newline \\
  |\seq c| > 0 \quad \neg \iswasmvalueinstr(wi) \\
  \casev ~ (str, \seq v) = wi \quad
  \seq e, \seq i = \lookup(\seq{a}, str) \quad
  \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
  \hline
  (\seq{a}, (wi ~ \seq{wi'}, \seq{wv}, sto), \wasm ~ (\seq c, k))
  \leadsto
  (\seq{a}, (\seq{wi'}, \seq{wv}, sto), \algo ~ (\seq i, \mu, \epsilon, \wasm ~ (\seq c, k))) \\
%
% Execute-value
\newline \\
  \iswasmvalueinstr(wi') \\
  \hline
  (\seq{a}, (\seq{wi}, \seq{wv}, sto), \exe ~ (wi', k))
  \leadsto
  (\seq{a}, (\seq{wi}, wi' ~ \seq{wv}, sto), k) \\
%
% Execute-instr
\newline \\
  \neg \iswasmvalueinstr(wi') \\
  \casev ~ (str, \seq v) = wi \quad
  \seq e, \seq i = \lookup(\seq{a}, str) \quad
  \mu = \assign([\text{"s"} \mapsto \storev], \seq e, \seq v) \\
  \hline
  (\seq{a}, w, \exe ~ (wi', k)) \leadsto (\seq{a}, w, \algo ~ (\seq i, \mu, \epsilon, k)) \\
\end{gather*}




%% Instruction

\newpage

\begin{gather*}
  \text{NOTE: input cont is always \algo} \\
  \seq{a}, ~ w, ~ k \vdash i \Rightarrow w, ~ k \\
%
% If-true
\newline \\
  \mu = \getenv(k) \quad w, \mu \vdash e \Rightarrow v \quad
  \istrue(v) \quad k' = \prependinstr(k, \seq{i_1}) \\
  \hline
  \seq{a}, w, k \vdash \ifi ~ (e, \seq{i_1}, \seq{i_2}) \Rightarrow (w, k') \\
%
% If-false
\newline \\
  \mu = \getenv(k) \quad w, \mu \vdash e \Rightarrow v \quad
  \neg \istrue(v) \quad k' = \prependinstr(k, \seq{i_2}) \\
  \hline
  \seq{a}, w, k \vdash \ifi ~ (e, \seq{i_1}, \seq{i_2}) \Rightarrow (w, k') \\
%
% Either-1
\newline \\
  \hline
  \seq{a}, w, k \vdash \eitheri ~ (\seq{i_1}, \seq{i_2}) \Rightarrow (w, \prependinstr(k, \seq{i_1})) \\
%
% Either-2
\newline \\
  \hline
  \seq{a}, w, k \vdash \eitheri ~ (\seq{i_1}, \seq{i_2}) \Rightarrow (w, \prependinstr(k, \seq{i_2})) \\
%
% Enter
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_1 \Rightarrow v_1 \quad
  w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \seq c = \getctx(k) \quad
  \seq{wi_{end}} = [ ~ \getendalgo(c) ~ | ~ c \leftarrow \seq c ~ ] \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), k \vdash \enteri ~ (e_1, e_2)
  \Rightarrow
  ((v_1 ~ \seq{wv}, \seq{v_2} ~ \seq{wi_{end}}~ \seq{wi}, sto), \wasm ~ (v_1 ~ \seq c, \resetctx(k))) \\
%
% PushCtx
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \pushctxi ~ e
  \Rightarrow
  (\push_{WasmValue}(w, v), \addctx(k, v)) \\
%
% Push
\newline \\
  w, \getenv(k) \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \pushi ~ e \Rightarrow (\push_{WasmValue}(w, v), k) \\
%
% PopCtx
\newline \\
  \mu = \getenv(k) \quad
  wv_{ctx} ~ \seq{wv'} = \exit_{WasmValue}(\seq{wv}) \quad
  \mu' = \assign(\mu, e, wv_{ctx}) \\
  k_1 = \setenv(k, \mu') \quad
  k_2 = \exit_{Cont}(k_1) \quad
  \seq{wi'} = \exit_{WasmInstr}(\seq{wi}) \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), k \vdash \popctxi ~ e
  \Rightarrow
  ((\seq{wv'}, \seq{wi'}, sto), k_2) \\
%
% Pop
\newline \\
  \mu = \getenv(k) \quad
  wv, w' = \pop_{WasmValue}(w) \quad
  \mu' = \assign(\mu, e, wv) \\
  \hline
  \seq{a}, w, k \vdash \popi ~ e \Rightarrow (w', \setenv(k, \mu')) \\
%
% PopN
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \quad
  wv^n, w' = \popn_{WasmValue}(w, n) \quad
  \mu' = \assign(\mu, e_1, \listv ~ wv^n) \\
  \hline
  \seq{a}, w, k \vdash \popni ~ (e_1, e_2) \Rightarrow (w', \setenv(k, \mu')) \\
%
% PopAll
\newline \\
  \mu = \getenv(k) \quad
  \seq{wv_0}, \seq{wv_1} = \splitctx(wv) \quad
  \mu' = \assign(\mu, e, \listv ~ \seq{wv_0}) \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), e \vdash \popalli ~ e
  \Rightarrow
  ((\seq{wv_1}, \seq{wi}, sto), \setenv(k, \mu')) \\
%
% Let
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_2 \Rightarrow v \quad
  \mu' = \assign(\mu, e_1, v) \\
  \hline
  \seq{a}, w, k \vdash \leti ~ (e_1, e_2)
  \Rightarrow
  (w, \setenv(k, \mu')) \\
%
% Trap
\newline \\
  \hline
  \seq{a}, w, k \vdash \trapi \Rightarrow (w, \ret ~ (\trapv, \mt)) \\
%
% Return-rule
\newline \\
  \hline
  \seq{a}, w, \algo~ (\seq{i}, \mu, \seq c, k) \vdash \returnrulei \Rightarrow (w, k) \\
%
% Return-func
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, \algo ~ (\seq{i}, \mu, \seq c, k) \vdash \returnfunci ~ e \Rightarrow (w, \ret ~ (v, k)) \\
%
% Execute
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e \Rightarrow v \\
  \hline
  \seq{a}, w, k \vdash \executei ~ e \Rightarrow (w, \exe ~ (v, k)) \\
%
% ExecuteSeq
\newline \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e \Rightarrow \listv ~ \seq v \quad
  k' = \fold(\execute, \seq v, k) \\
  \hline
  \seq{a}, w, k \vdash \executeseqi ~ e \Rightarrow (w, k') \\
%
% Call-fname
\newline \\
  \mu = \getenv(k) \quad
  \fnamev ~ str_2 = \mu(str_1) \quad
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  \seq{a}, w, k \vdash \calli ~ (str_0, str_1, \seq e) \Rightarrow (w, \call ~ (str_0, str_2, \seq v, k)) \\
%
% Call-fname
\newline \\
  \mu = \getenv(k) \quad
  str_1 \not\in \domain(\mu) \quad
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  \seq{a}, w, k \vdash \calli ~ (str_0, str_1, \seq e) \Rightarrow (w, \call ~ (str_0, str_1, \seq v, k)) \\
%
% Replace-frame
\newline \\
\text{NOTE: $e_1$ is either store or current frame} \\
  \mu = \getenv(k) \quad
  w, \mu \vdash e_1 \Rightarrow v_1 \quad
  \isframe(v_1) \quad
  w, \mu \vdash e_2 \Rightarrow v_2 \quad
  v_3 = \update(v_1, \seq p, v_2) \\
  \hline
  \seq{a}, w, k \vdash \replacei ~ (e_1, \seq{path}, e_2) \Rightarrow (\setcurframe(w, v_3), k) \\
%
% Replace-store
\newline \\
  w, \mu \vdash e_1 \Rightarrow \storev \quad
  \mu = \getenv(k) \quad
  w, \mu \vdash e_2 \Rightarrow v_2 \quad
  sto' = \update_{Sto}(sto, \seq p, v_2) \\
  \hline
  \seq{a}, (\seq{wv}, \seq{wi}, sto), k \vdash \replacei ~ (e_1, \seq{path}, e_2)
  \Rightarrow ((\seq{wv}, \seq{wi}, sto'), k) \\
\end{gather*}





%% Expression

\begin{gather*}
  w, \mu \vdash e \Rightarrow v
%
% Var
\newline \\
  v = \mu(str) \\
  \hline
  w, \mu \vdash \vare ~ str \Rightarrow v \\
%
% Num
\newline \\
  \hline
  w, \mu \vdash \nume ~ n \Rightarrow \numv ~ n \\
%
% Bool
\newline \\
  \hline
  w, \mu \vdash \boole ~ b \Rightarrow \boolv ~ b \\
%
% Fname
\newline \\
  \hline
  w, \mu \vdash \fnamee ~ str \Rightarrow \fnamev ~ str \\
%
% Un
\newline \\
  w, \mu e \Rightarrow v \\
  \hline
  w, \mu \vdash \une ~ (unop, e) \Rightarrow \unop(unop, v) \\
%
% Bin
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \bine ~ (binop, e_1, e_2) \Rightarrow \binop(binop, v_1, v_2) \\
%
% Acc
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \acce ~ (e, path) \Rightarrow \access(w, \mu, v, path) \\
%
% Upd
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \upde ~ (e_1, \seq path, e_2) \Rightarrow \update(v_1, \seq path, v_2) \\
%
% Str
\newline \\
  \seq{(str, v)} =
    [ ~
      str, v
    ~ | ~
      (str, e) \leftarrow \seq{(str, e)}; w, \mu \vdash e \Rightarrow v
    ~ ] \\
  \hline
  w, \mu \vdash \stre ~ \seq{(str, e)} \Rightarrow \strv ~ \seq{(str, v)} \\
%
% Comp
\newline \\
   w, \mu \vdash e_1 \Rightarrow \strv ~ \seq{(str_1, v_1)} \quad
   w, \mu \vdash e_2 \Rightarrow \strv ~ \seq{(str_2, v_2)} \\
  \hline
  w, \mu \vdash \compe ~ (e_1, e_2) \Rightarrow \strv ~ (\seq{(str_1, v_1)} ~ \seq{(str_2, v_2)}) \\
%
% Cat
\newline \\
   w, \mu \vdash e_1 \Rightarrow \listv ~ \seq{v_1} \quad
   w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \hline
  w, \mu \vdash \cate ~ (e_1, e_2) \Rightarrow \listv ~ (\seq{v_1} ~ \seq{v_1}) \\
%
% Mem
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad
  w, \mu \vdash e_2 \Rightarrow \listv ~ \seq{v_2} \\
  \hline
  w, \mu \vdash \meme ~ (e_1, e_2) \Rightarrow \boolv ~ (v_1 \in \seq{v_2}) \\
%
% Len
\newline \\
  w, \mu \vdash e \Rightarrow \listv ~ \seq{v} \\
  \hline
  w, \mu \vdash \lene ~ e \Rightarrow \numv ~ |\seq v| \\
%
% Tup
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \tupe ~ \seq{e} \Rightarrow \tupv ~ \seq{v} \\
%
% Case
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \casee ~ (str, \seq{e}) \Rightarrow \casev ~ (str, \seq{v}) \\
%
% Iter-
\newline \\
  f =
    (\lambda ~ str ~ acc. ~
      \listv ~ \seq v = \mu(str); ~
      [ ~ \mu_1[str \mapsto v] ~ | ~ (v, \mu_1) \leftarrow \zip (\seq v, acc) ~ ]
    )
  \\
  \seq{\mu_2} = \fold(f, \seq{str}, \duplicateenv(\mu, \seq{str})) \quad
  \seq{v'} =
    [ ~
      v'
    ~ | ~
      \mu_3 \leftarrow \seq {\mu_2}; ~ w, \mu_3 \vdash e \Rightarrow v'
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e, \listiter, \seq{str}) \Rightarrow \listv ~ \seq{v'} \\
%
% Iter-n
\newline \\
  w, \mu \vdash e_2 \Rightarrow \numv ~ n \\
  f_i =
    (\lambda ~ x ~ acc. ~
      \listv ~ \seq v = \mu(x); ~
      [ ~ \mu_1[str \mapsto v] ~ | ~ (v, \mu_1) \leftarrow \zip (\seq v, acc) ~ ]
    )
  \\
  \seq{\mu_2} = \fold(f, \seq{str}, \mu^n) \quad
  \seq{v'} =
    [ ~
      v'
    ~ | ~
      \mu_3 \leftarrow \seq {\mu_2}; ~ w, \mu_3 \vdash e_1 \Rightarrow v'
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listniter ~ e_2, \seq{str}) \Rightarrow \listv ~ \seq{v'} \\
%
% Iter-idx
\newline \\
  \seq{\mu_1} =
    [ ~
      \fold(
        (\lambda ~ x ~ acc. ~ acc[x \mapsto \numv ~ i]),
        \seq{str},
        \mu
      )
    ~ | ~
      i \leftarrow [0 ~ .. ~ n-1]
    ~ ]
  \quad
  \seq{v'} =
    [ ~
      v'
    ~ | ~
      \mu_2 \leftarrow \seq {\mu_1}; ~ w, \mu_2 \vdash e_1 \Rightarrow v'
    ~ ] \\
  \hline
  w, \mu \vdash \itere ~ (e_1, \listidxiter ~ e_2, \seq{str}) \Rightarrow \listv ~ \seq{v'} \\
%
% List
\newline \\
  \seq{v} = [ ~ v ~ | ~ e \leftarrow \seq{e}; ~ w, \mu \vdash e \Rightarrow v ~ ] \\
  \hline
  w, \mu \vdash \liste ~ \seq{e} \Rightarrow \listv ~ \seq{v} \\
%
% GetCurCtx
\newline \\
  v_{ctx} = \getcurctx(w, str) \\
  \hline
  w, \mu \vdash \getcurctxe ~ str \Rightarrow v_{ctx} \\
%
% Choose
\newline \\
  w, \mu \vdash e \Rightarrow \listv ~ \seq{v} \quad
  v' \in \seq{v} \\
  \hline
  w, \mu \vdash \choosee ~ e \Rightarrow v' \\
%
% IsCaseOf
\newline \\
  w, \mu \vdash e \Rightarrow \casev ~ (str', \seq{v}) \\
  \hline
  w, \mu \vdash \iscaseofe ~ (e, str) \Rightarrow \boolv ~ (str = str') \\
%
% IsValid
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \isvalide ~ e \Rightarrow \boolv ~ (\isvalid(v)) \\
%
% CtxKind
\newline \\
  \casev (str', \seq v) = \getcurctx(w, str) \\
  \hline
  w, \mu \vdash \ctxkinde ~ str \Rightarrow \boolv ~ (str = str') \\
%
% Match
\newline \\
  w, \mu \vdash e_1 \Rightarrow v_1 \quad
  w, \mu \vdash e_2 \Rightarrow v_2 \\
  \hline
  w, \mu \vdash \matche ~ (e_1, e_2) \Rightarrow \boolv ~ (\match(v_1, v_2)) \\
%
% HasType
\newline \\
  w, \mu \vdash e \Rightarrow v \\
  \hline
  w, \mu \vdash \hastypee ~ (e, str) \Rightarrow \boolv ~ (\hastype(v, str)) \\
\end{gather*}




%% Helper functions

\begin{align*}
%
% lookup
  &str' = str \\
  \hline
  &\lookup((str', \seq e, \seq i) ~ \seq{a'}, str) = \seq e, \seq i \\
  &str' \not= str \\
  \hline
  &\lookup((str, \seq e, \seq i) ~ \seq{a'}, str) = \lookup(\seq{a'}, str) \\
%
% pop_all-ctx
\newline \\
&\text{NOTE: an input of is\_ctx (WasmValue sequence) contains at least one context} \\
  &\text{is\_ctx}(\text{hd}(\seq{wv})) \\
  \hline
  &\splitctx(\seq{wv}) = \epsilon, \seq{wv} \\
% pop_all-val
  &\text{is\_not\_ctx}(wv_0) \quad \seq{wv_2}, \seq{wv_3} = \splitctx(\seq{wv_1}) \\
  \hline
  &\splitctx(wv_0 ~ \seq{wv_1}) = wv_0 ~ \seq{wv_2}, \seq{wv_3} \\
%
% execute
\newline \\
  &\execute(v, k) = \exe(v, k) \\
%
% exit_cont-wasm_0
\newline \\
&\text{NOTE: input cont of exit is either \algo ~ or \wasm} \\
  &\exit_{Cont}(\wasm (\epsilon, k)) = \wasm(\epsilon, \exit_{Cont}(k)) \\
% exit_cont-wasm_nonzero
  &\exit_{Cont}(\wasm (c ~ \seq c', k)) = \wasm(\seq c', k) \\
% exit_cont-al
  &\exit_{Cont}(\algo (\seq i, \mu, \seq c, k)) = \algo (\seq i, \mu, \seq c, \exit(k)) \\
%
% exit_wasm_instr-end
\newline \\
  &\text{is\_end}(wi) \\
  \hline
  &\exit_{WasmInstr}(wi ~ \seq{wi'}) = \seq{wi'} \\
% exit_wasm_instr-normal_instr
  &\text{is\_not\_end}(wi) \\
  \hline
  &\exit_{WasmInstr}(wi ~ \seq{wi'}) = \exit_{WasmInstr}(\seq{wi'}) \\
%
% exit_wasm_value
  &\seq{wv_1}, \seq{wv_2} = \splitctx(\seq{wv_0}) \\
  \hline
  &\exit_{WasmValue}(\seq{wv_0}) = \seq{wv_2} \\
%
% duplicate_env-empty
\newline \\
  &\duplicateenv(\mu, epsilon) = \mu \\
% duplicate_env-nonempty
  &\listv ~ \seq v = \mu(str) \\
  \hline
  &\duplicateenv(\mu, str ~ \seq{str'}) = \mu^{|\seq v|} \\
%
% get_env
\newline \\
  &\getenv(\algo ~ (\seq i, \mu, \seq c, k)) = \mu \\
%
% set_env
\newline \\
  &\setenv(\algo ~ (\seq i, \mu, \seq c, k), \mu') = \algo ~ (\seq i, \mu', \seq c, k) \\
%
% prepend_instr
\newline \\
  &\prependinstr(\algo ~ (\seq i, \mu, \seq c, k), \seq{i'}) = \algo ~ (\seq{i'} ~ \seq i, \mu, \seq c, k) \\
%
% get_ctx
\newline \\
  &\getctx(\algo ~ (\seq i, \mu, \seq c, k)) = \seq c \\
%
% add_ctx
\newline \\
  &\addctx(\algo ~ (\seq i, \mu, \seq c, k), c') = \algo ~ (\seq i, \mu, c' ~ \seq c, k) \\
%
% reset_ctx
\newline \\
  &\resetctx(\algo ~ (\seq i, \mu, \seq c, k)) = \algo ~ (\seq i, \mu, \epsilon, k) \\
%
% push
\newline \\
  &\push((\seq{wv}, \seq{wi}, sto), wv') = wv' ~ \seq{wv}, \seq{wi}, sto \\
%
% pop
\newline \\
  &\pop((wv ~ \seq{wv'}, \seq{wi}, sto)) = \seq{wv'}, \seq{wi}, sto \\
%
% popn
\newline \\
  &\popn((wv^n ~ \seq{wv'}, \seq{wi}, sto), n) = \seq{wv'}, \seq{wi}, sto \\
%
% unop
\newline \\
  &\istrue(v) \\
  \hline
  &\unop(\notop, v) = \boolv ~ false \\
  &\neg\istrue(v) \\
  \hline
  &\unop(\notop, v) = \boolv ~ true \\
  &\unop(\minusop, \numv ~ n) = \numv ~ (-n) \\
%
% get_cur_ctx
\newline \\
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \\
  \hline
  &\getcurctx((\seq{wv}, \seq{wi}, sto)) = wv_{ctx} \\
%
% get_cur_frame-frame
\newline \\
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \quad \isframe(wv_{ctx}) \\
  \hline
  &\getcurframe((\seq{wv}, \seq{wi}, sto)) = wv_{ctx} \\
% get_cur_frame-other
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \quad \neg \isframe(wv_{ctx}) \\
  \hline
  &\getcurframe((\seq{wv}, \seq{wi}, sto)) = \getcurframe(\seq{wv_2}) \\
%
% set_cur_frame-frame
\newline \\
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \quad \isframe(wv_{ctx}) \\
  \hline
  &\setcurframe((\seq{wv}, \seq{wi}, sto), v_{frame})
  =
  \seq{wv_1} ~ v_{frame} ~ \seq{wv_2}, \seq{wi}, sto \\
% set_cur_frame-other
  &\seq{wv_1}, wv_{ctx} ~ \seq{wv_2} = \splitctx(\seq{wv}) \quad \neg \isframe(wv_{ctx}) \\
  \hline
  &\setcurframe((\seq{wv}, \seq{wi}, sto), v_{frame})
  =
  \seq{wv_1} ~ wv_{ctx} ~ \setcurframe(\seq{wv_2}, v_{frame}), \seq{wi}, sto \\
%
% access-idx
\newline \\
  &\numv ~ n = \sem{e}(\mu, w) \quad \listv ~ \seq{v'} = v \\
  \hline
  &\access(\mu, w, v, \idxp ~ e) = \seq{v'}[n] \\
% access-slice
  &\numv ~ n_1 = \sem{e_1}(\mu, w) \quad
  \numv ~ n_2 = \sem{e_2}(\mu, w) \quad
  \listv ~ \seq{v'} = v \\
  \hline
  &\access(\mu, w, v, \slicep ~ (e_1, e_2)) = \seq{v'}[n_1: n_2] \\
% access-dot
  &\strv ~ ((str_0, v_0) ~ \seq{(str_1, v_1)}) = v \quad
  str_0 = str \\
  \hline
  &\access(\mu, w, v, \dotp ~ str) = v_0 \\
  &\strv ~ ((str_0, v_0) ~ \seq{(str_1, v_1)}) = v \quad
  str_0 \not= str \\
  \hline
  &\access(\mu, w, v, \dotp ~ str) = \access(\mu, w, \strv ~ \seq{(str_1, v_1)}, \dotp ~ str) \\
% access-store
  &\storev = v \\
  \hline
  &\access(\mu, (\seq{wv}, \seq{wi}, sto), v, \dotp ~ str) = sto(str) \\
%
% update-idx
\newline \\
  &\numv ~ n = \sem{e}(\mu, w) \quad
  \listv ~ \seq{v_3} = v_1 \\
  \hline
  &\update(\mu, w, v_1, (\idxp ~ e) ~ \seq{path}, v_2)
  =
  \updateidx(v_3, n, \update(\mu, w, \seq{v_3}[n], \seq{path}, v_2)) \\
% update_idx
  &\updateidx(v_0 ~ \seq{v_1}, 0, v_2) =  v_2 ~ \seq{v_1} \\
  &n > 0 \\
  \hline
  &\updateidx(v_0 ~ \seq{v_1}, n, v_2) =  v_0 ~ \updateidx(\seq{v_1}, n-1, v_2) \\
%
% update-slice
\newline \\
  &\numv ~ n_1 = \sem{e_1}(\mu, w) \quad
  \numv ~ n_2 = \sem{e_2}(\mu, w) \quad
  \listv ~ \seq{v_3} = v_1 \\
  \hline
  &\update(\mu, w, v_1, (\slicep ~ e) ~ \seq{path}, v_2)
  =
  \updateslice(v_3, n_1, n_2, \update(\mu, w, \seq{v_3}[n_1: n_2], \seq{path}, v_2)) \\
% update_slice
  &\updateslice(v_0^n ~ \seq{v_1}, 0, n, v_2^n) = v_2^n ~ \seq{v_1} \\
  &m > 0 \\
  \hline
  &\updateslice(v_0 ~ \seq{v_1}, m, n, v_2^n) =  v_0 ~ \updateslice(\seq{v_1}, m-1, n, v_2) \\
%
% update-dot
\newline \\
  &\strv ~ \seq{(str', v')} = v \\
  \hline
  &\update(\mu, w, v, (\dotp ~ str) ~ \seq{path}, v_2)
  =
  \updatedot(\seq{(str', v')}, str, \update(\mu, w, \access(v, \dotp ~ str), \seq{path}, v_2)) \\
% update_dot
  &str_0 = str_2 \\
  \hline
  &\updatedot((str_0, v_0) ~ \seq{(str_1, v_1)}, str_2, v_2)
  =
  (str_2, v_2) ~ \seq{(str_1, v_1)} \\
  &str_0 \not= str_2 \\
  \hline
  &\updatedot((str_0, v_0) ~ \seq{(str_1, v_1)}, str_2, v_2)
  =
  (str_0, v_0) ~ \updatedot(\seq{(str_1, v_1)}, str_2, v_2) \\
%
% get_end_algo
\newline \\
  &\getendalgo(\casev(\text{"LABEL"}, \epsilon)) = \casev(\text{"EXTING"}, \epsilon) \\
  &\getendalgo(\casev(\text{"FRAME"}, \epsilon)) = \casev(\text{"RETURNING"}, \epsilon) \\
%
% is_true
\newline \\
  &\istrue(\boolv ~ b) = b \\
  &\istrue(\listv ~ \seq v) = \forall v' \in \seq v. \istrue (v') \\
%
% is_frame
\newline \\
  &\isframe(\casev ~ (\text{"FRAME"}, \seq v)) = true \\
  &otherwise \\
  \hline
  &\isframe(v) = false \\
%
% zip
\newline \\
  &\zip(eps, eps) = eps \\
  &\zip(x ~ \seq{x'}, y ~ \seq{y'}) = (x, y) ~ \zip (\seq{x'}, \seq{y'}) \\
%
% fold
\newline \\
  &\fold(f, x^n, acc) = f(x_0, f(x_1, ~ ... ~ f(x_{n-2}, f(x_{n-1}, acc)) ~ ... ~ ))
\end{align*}





