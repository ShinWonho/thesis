% !TEX root = main.tex

\chapter{Semantics}
\label{ch:semantics}
\noindent


% AL semantics formalize
%
%
% Prose notation:
% - Implicit when to exit:
%   • Returning from a function
%     When the end of a function is reached without a jump (i.e., return) or trap aborting it, then the following steps are performed.
%
%   • Exiting with label
%     When the end of a block is reached without a jump or trap aborting it, then the following steps are performed.
%
%   ! end of function/label is defined verbally, not in algorithmic notation
%
% - Separate context and instructions:
%   • Push ctx \& Jump instrs
%
%
% abstract machine of prose notation: vm
% 1. state: stack, store
% 2. cosumes sequence of WebAssembly instruction
% 3. mutate state
%
% - store
%   - instantiate -> alloc
%   - invoke -> use
% - stack contains value \& context
%   - value
%     ex: binop
%   - context
%     1) label: allow structured control flow (continuation)
%     2) frame: store call information (local variable, module instance)
%     - enter \& exit
%     - ex: loop, invoke
%     - ex: br, implicit exit
%
%
% - wrong interpretation of "end" in AL interpreter \red{(How long does it occur?)}
% - example




%% Symbol definition

% Continuation
\newcommand{\mt}{\textbf{Empty}}
\newcommand{\call}{\textbf{Call}}
\newcommand{\al}{\textbf{Al}}
\newcommand{\enter}{\textbf{Enter}}
\newcommand{\wasm}{\textbf{Wasm}}
\newcommand{\exe}{\textbf{Execute}}
\newcommand{\ret}{\textbf{Return}}

% Instruction
\newcommand{\ifi}{\textbf{IfI}}
\newcommand{\eitheri}{\textbf{EitherI}}
\newcommand{\enteri}{\textbf{EnterI}}
\newcommand{\pushctxi}{\textbf{PushCtxI}}
\newcommand{\pushi}{\textbf{PushI}}
\newcommand{\popi}{\textbf{PopI}}
\newcommand{\popni}{\textbf{PopNI}}
\newcommand{\popalli}{\textbf{PopAllI}}
\newcommand{\leti}{\textbf{LetI}}
\newcommand{\trapi}{\textbf{TrapI}}
\newcommand{\nopi}{\textbf{NopI}}
\newcommand{\returni}{\textbf{ReturnI}}
\newcommand{\executei}{\textbf{ExecuteI}}
\newcommand{\executeseqi}{\textbf{ExecuteSeqI}}
\newcommand{\performi}{\textbf{PerformI}}
\newcommand{\exiti}{\textbf{ExitI}}
\newcommand{\replacei}{\textbf{ReplaceI}}

% Expression
\newcommand{\vare}{\textbf{VarE}}
\newcommand{\nume}{\textbf{NumE}}
\newcommand{\boole}{\textbf{BoolE}}
\newcommand{\fnamee}{\textbf{FnameE}}
\newcommand{\une}{\textbf{UnE}}
\newcommand{\bine}{\textbf{BinE}}
\newcommand{\acce}{\textbf{AccE}}
\newcommand{\upde}{\textbf{UpdE}}
\newcommand{\stre}{\textbf{StrE}}
\newcommand{\compe}{\textbf{CompE}}
\newcommand{\cate}{\textbf{CatE}}
\newcommand{\meme}{\textbf{MemE}}
\newcommand{\lene}{\textbf{LenE}}
\newcommand{\tupe}{\textbf{TupE}}
\newcommand{\casee}{\textbf{CaseE}}
\newcommand{\calle}{\textbf{CallE}}
\newcommand{\itere}{\textbf{IterE}}
\newcommand{\liste}{\textbf{ListE}}
\newcommand{\getcurcontexte}{\textbf{GetCurContextE}}
\newcommand{\choosee}{\textbf{ChooseE}}
\newcommand{\iscaseofe}{\textbf{IsCaseOfE}}
\newcommand{\contextkinde}{\textbf{ContextKindE}}
\newcommand{\matche}{\textbf{MatchE}}
\newcommand{\hastypee}{\textbf{HasTypeE}}

% Unary operator
\newcommand{\notop}{\textbf{NotOp}}
\newcommand{\minusop}{\textbf{MinusOp}}

% Binary operator
\newcommand{\addop}{\textbf{AddOp}}
\newcommand{\subop}{\textbf{SubOp}}
\newcommand{\mulop}{\textbf{MulOp}}
\newcommand{\divop}{\textbf{DivOp}}
\newcommand{\modop}{\textbf{ModOp}}
\newcommand{\expop}{\textbf{ExpOp}}
\newcommand{\implop}{\textbf{ImplOp}}
\newcommand{\equivop}{\textbf{EquivOp}}
\newcommand{\andop}{\textbf{AndOp}}
\newcommand{\orop}{\textbf{OrOp}}
\newcommand{\eqop}{\textbf{EqOp}}
\newcommand{\neop}{\textbf{NeOp}}
\newcommand{\ltop}{\textbf{LtOp}}
\newcommand{\gtop}{\textbf{GtOp}}
\newcommand{\leop}{\textbf{LeOp}}
\newcommand{\geop}{\textbf{GeOp}}

% Path
\newcommand{\idxp}{\textbf{Idx}}
\newcommand{\slicep}{\textbf{Slice}}
\newcommand{\dotp}{\textbf{Dot}}

% Iter
\newcommand{\listiter}{\textbf{List}}
\newcommand{\listniter}{\textbf{ListN}}
\newcommand{\listidxiter}{\textbf{Index}}

% Value
\newcommand{\numv}{\textbf{NumV}}
\newcommand{\boolv}{\textbf{BoolV}}
\newcommand{\listv}{\textbf{ListV}}
\newcommand{\strv}{\textbf{StrV}}
\newcommand{\casev}{\textbf{CaseV}}
\newcommand{\tupv}{\textbf{TupV}}
\newcommand{\fnamev}{\textbf{FnameV}}
\newcommand{\trapv}{\textbf{TrapV}}

% Helper function
\newcommand{\lookup}{\text{lookup}}
\newcommand{\assign}{\text{assign}}
\newcommand{\getenv}{\text{get\_env}}
\newcommand{\setenv}{\text{set\_env}}
\newcommand{\iswasmvalueinstr}{\text{is\_wasm\_value\_instr}}
\newcommand{\isnotwasmvalueinstr}{\text{is\_not\_wasm\_value\_instr}}
\newcommand{\istrue}{\text{is\_true}}
\newcommand{\isfalse}{\text{is\_false}}
\newcommand{\prependinstr}{\text{prepend\_instr}}
\newcommand{\tolist}{\text{tolist}}
\newcommand{\push}{\text{push}}
\newcommand{\pop}{\text{pop}}
\newcommand{\popn}{\text{popn}}
\newcommand{\increasectxcnt}{\text{increase\_ctx\_cnt}}
\newcommand{\splitctx}{\text{split\_ctx}}
\newcommand{\foldright}{\text{fold\_right}}
\newcommand{\execute}{\text{execute}}
\newcommand{\exit}{\text{exit}}
\newcommand{\isframe}{\text{is\_frame}}
\newcommand{\isstore}{\text{is\_store}}
\newcommand{\updatecurframe}{\text{update\_cur\_frame}}
\newcommand{\updatestore}{\text{update\_store}}




%% Syntax

\begin{align*}
%
% State
  s \in S =& W \times Cont \\
%
% Wasm state
  w \in W =& \seq{WasmValue} \times \seq{WasmInstr} \times Store \\
  wv \in WasmValue =& V \\
  wi \in WasmInstr =& V \\
%
% Store
  sto \in Store =& String \mapsto \seq V \\
%
% Continuation
  c \in Cont =& ~ \mt \\
    | & ~ \call ~ String \times \seq V \times Cont \\
    | & ~ \al ~ \seq I \times Env \times \mathbb N \times Cont \\
    | & ~ \wasm ~ \mathbb N \times Cont \\
    | & ~ \exe ~ wi \times Cont \\
    | & ~ \ret ~ V \\
%
% Environment
  \mu \in Env =& String \mapsto V \\
%
% Instruction
  i \in I =& ~ \ifi ~ E \times \seq I \times \seq I \\
    | & ~ \eitheri ~ \seq I \times \seq I \\
    | & ~ \enteri ~ E \times E \\
    | & ~ \pushctxi ~ E \\
    | & ~ \pushi ~ E \\
    | & ~ \popi ~ E \\
    | & ~ \popni ~ E \times E \\
    | & ~ \popalli ~ E \\
    | & ~ \leti ~ E \times E \\
    | & ~ \trapi \\
    | & ~ \returni ~ E_{\bot} \\
    | & ~ \executei ~ E \\
    | & ~ \executeseqi ~ E \\
    | & ~ \performi ~ String \times \seq{E} \\
    | & ~ \exiti ~ String \\
    | & ~ \replacei ~ E \times \seq P \times E \\
%
% Expression
  e \in E =& ~ \vare ~ String \\
    | & ~ \nume ~ \mathbb N \\
    | & ~ \boole ~ \mathbb B \\
    | & ~ \fnamee ~ String \\
    | & ~ \une ~ Unop \times E \\
    | & ~ \bine ~ Binop \times E \times E \\
    | & ~ \acce ~ E \times P \\
    | & ~ \upde ~ E \times \seq P \times E \\
    | & ~ \stre ~ String \mapsto E \\
    | & ~ \compe ~ E \times E \\
    | & ~ \cate ~ E \times E \\
    | & ~ \meme ~ E \times E \\
    | & ~ \lene ~ E \\
    | & ~ \tupe ~ \seq E \\
    | & ~ \casee ~ String \times \seq E \\
    | & ~ \calle ~ String \times \seq E \\
    | & ~ \itere ~ E \times Iter \times \seq{String} \\
    | & ~ \liste ~ \seq E \\
    | & ~ \getcurcontexte ~ String \\
    | & ~ \choosee ~ E \\
    | & ~ \iscaseofe ~ E \times String \\
    | & ~ \contextkinde ~ String \\
    | & ~ \matche ~ E \times E \\
    | & ~ \hastypee ~ E \times String \\
%
% Operator
  unop \in Unop =& ~ \notop ~ | ~ \minusop \\
  binop \in Binop =& ~ \addop \\
    | & ~ \subop \\
    | & ~ \mulop \\
    | & ~ \divop \\
    | & ~ \modop \\
    | & ~ \expop \\
    | & ~ \implop \\
    | & ~ \equivop \\
    | & ~ \andop \\
    | & ~ \orop \\
    | & ~ \eqop \\
    | & ~ \neop \\
    | & ~ \ltop \\
    | & ~ \gtop \\
    | & ~ \leop \\
    | & ~ \geop \\
%
% Path
  p \in P =& ~ \idxp ~ E ~ | ~ \slicep ~ E \times E ~ | ~ \dotp ~ String \\
%
% Iter
  iter \in Iter =& ~ \listiter ~ | ~ \listniter ~ E ~|~ \listidxiter ~ String \times E \\
%
% Value
  v \in V =& ~ \numv ~ \mathbb N \\
    | & ~ \boolv ~ \mathbb B \\
    | & ~ \listv ~ \seq V \\
    | & ~ \strv ~ String \times \mapsto V \\
    | & ~ \casev ~ String \times \seq V \\
    | & ~ \tupv ~ \seq V \\
    | & ~ \fnamev String \\
\end{align*}




%% Step

\newpage

\begin{gather*}
\newline \\
  S \leadsto S
%
% Call
\newline \\
  \seq e, \seq i = \lookup(str) \quad \mu = \assign(\seq e, \seq v) \\
  \hline
  (w, \call (str, \seq v, c)) \leadsto (w, \al (\seq i, \mu, c)) \\
%
% Al-empty_zero
\newline \\
  \hline
  (w, \al (\epsilon, \mu, 0, c)) \leadsto (w, c) \\
%
% Al-empty_nonzero
\newline \\
  n > 0 \\
  \hline
  (w, \al (\epsilon, \mu, n, c)) \leadsto (w, \wasm (n, c)) \\
%
% Al-instr
\newline \\
  \hline
  (w, \al (i_0 ~ \seq{i_1}, \mu, n, c)) \leadsto \sem{i_0}(w, \al (\seq{i_1}, \mu, n, c)) \\
%
% Wasm-zero
\newline \\
  \hline
  (w, \wasm (0, c)) \leadsto (w, c) \\
%
% Wasm-value
\newline \\
  n > 0 \quad \iswasmvalueinstr(wi) \\
  \hline
  ((wi ~ \seq{wi'}, \seq{wv}, sto), \wasm (n, c))
  \leadsto
  ((\seq{wi'}, wi ~ \seq{wv}, sto), \wasm (n, c)) \\
%
% Wasm-instr
\newline \\
  n > 0 \quad \isnotwasmvalueinstr(wi) \\
  \casev (str, \seq v) = wi \quad
  \seq e, \seq i = \lookup(str) \quad
  \mu = \assign(\epsilon, \seq e, \seq v) \\
  \hline
  ((wi ~ \seq{wi'}, \seq{wv}, sto), \wasm (n, c))
  \leadsto
  ((\seq{wi'}, \seq{wv}, sto), \al (\seq i, \seq v, \wasm (n, c))) \\
%
% Execute-value
\newline \\
  \iswasmvalueinstr(wi') \\
  \hline
  ((\seq{wi}, \seq{wv}, sto), \exe (wi', c))
  \leadsto
  ((\seq{wi}, wi' ~ \seq{wv}, sto), c) \\
%
% Execute-instr
\newline \\
  \isnotwasmvalueinstr(wi') \\
  \casev (str, \seq v) = wi \quad
  \seq e, \seq i = \lookup(str) \quad
  \mu = \assign(\epsilon, \seq e, \seq v) \\
  \hline
  (w, \exe (wi', c)) \leadsto (w, \al (\seq i, \seq v, c)) \\
\end{gather*}




%% AL Instr

\newpage

\begin{gather*}
  \text{NOTE: input cont is always \al} \\
  \sem{i} : State \rightarrow State \\
%
% If-true
\newline \\
  \mu = \getenv(c) \quad v = \sem{e}(\mu, w) \quad
  \istrue(v) \quad c' = \prependinstr(c, \seq{i_1}) \\
  \hline
  \sem{\ifi ~ (e, \seq{i_1}, \seq{i_2})}(w, c) = (w, c') \\
%
% If-false
\newline \\
  \mu = \getenv(c) \quad v = \sem{e}(\mu, w) \quad
  \isfalse(v) \quad c' = \prependinstr(c, \seq{i_2}) \\
  \hline
  \sem{\ifi ~ (e, \seq{i_1}, \seq{i_2})}(w, c) = (w, c') \\
%
% Either-1
\newline \\
  \hline
  \sem{\eitheri ~ (\seq{i_1}, \seq{i_2})}(w, c) = (w, \prependinstr(c, \seq{i_1})) \\
%
% Either-2
\newline \\
  \hline
  \sem{\eitheri ~ (\seq{i_1}, \seq{i_2})}(w, c) = (w, \prependinstr(c, \seq{i_2})) \\
%
% Enter
\newline \\
  \mu = \getenv(c) \quad v_1 = \sem{e_1}(\mu, w) \quad v_2 = \sem{e_2}(\mu, w) \\
  \hline
  \sem{\enteri ~ (e_1, e_2)}((\seq{wv}, \seq{wi}, sto), c)
  =
  ((v_1 ~ \seq{wv}, \tolist(v_2) ~ \seq{wi}, sto), \wasm (n+1, c)) \\
%
% PushCtx
\newline \\
  \mu = \getenv(c) \quad v = \sem{e}(\mu, w) \\
  \hline
  \sem{\pushctxi ~ e}(w, c)
  =
  (\push_{WasmValue}(w, v), \increasectxcnt(c)) \\
%
% Push
\newline \\
  v = \sem{e}(\mu, w) \\
  \hline
  \sem{\pushi ~ e}(w, c) = (\push_{WasmValue}(w, v), c) \\
%
% Pop
\newline \\
  \mu = \getenv(c) \quad
  wv, w' = \pop_{WasmValue}(w) \quad
  \mu' = \assign(\mu, e, wv) \\
  \hline
  \sem{\popi ~ e}(w, c) = (w', \setenv(c, \mu')) \\
%
% PopN
\newline \\
  \mu = \getenv(c) \quad
  \sem{e_2}(\mu, w) = \numv ~ n \quad
  wv^n, w' = \popn_{WasmValue}(w, n) \quad
  \mu' = \assign(\mu, e_1, \listv ~ wv^n) \\
  \hline
  \sem{\popni ~ (e_1, e_2)}(w, c) = (w', \setenv(c, \mu')) \\
%
% PopAll
\newline \\
  \mu = \getenv(c) \quad
  \seq{wv_0}, \seq{wv_1} = \splitctx(wv) \quad
  \mu' = \assign(\mu, e, \listv ~ \seq{wv_0}) \\
  \hline
  \sem{\popalli ~ e}(\seq{wv}, \seq{wi}, sto), c)
  =
  ((\seq{wv_1}, \seq{wi}, sto), \setenv(c, \mu')) \\
%
% Let
\newline \\
  \mu = \getenv(c) \quad
  v = \sem{e_2}(\mu, w) \quad
  \mu' = \assign(\mu, e_1, v) \\
  \hline
  \sem{\leti ~ (e_1, e_2)}(w, c)
  =
  (w, \setenv(c, \mu')) \\
%
% Trap
\newline \\
  \hline
  \sem{\trapi}(w, c) = (w, \ret ~ \trapv) \\
%
% Return-none
\newline \\
  \hline
  \sem{\returni}(w, \al (\seq{i}, \mu, n, c)) = (w, c) \\
%
% Return-some
\newline \\
  \sem{e}(\mu, w) = v \\
  \hline
  \sem{\returni ~ e}(w, \al (\seq{i}, \mu, n, c)) = (w, \ret ~ v) \\
%
% Execute
\newline \\
  \mu = \getenv(c) \quad
  \sem{e}(\mu, w) = v \\
  \hline
  \sem{\executei ~ e}(w, c) = (w, \exe (v, c)) \\
%
% ExecuteSeq
\newline \\
  \mu = \getenv(c) \quad
  \sem{e}(\mu, w) = v \quad
  c' = \foldright(\execute, \tolist(v), c) \\
  \hline
  \sem{\executeseqi ~ e}(w, c) = (w, c') \\
%
% Perform
\newline \\
  \mu = \getenv(c) \quad
  \seq v = \seq{\sem{e}}(\mu, w) \\
  \hline
  \sem{\performi ~ (str, \seq e)}(w, c) = (w, \call (str, \seq v, c)) \\
%
% Exit
\newline \\
  \seq{wv'} = \exit_{WasmValue}(\seq{wv}) \quad
  c' = \exit_{Cont}(c) \quad
  \seq{wi'} = \exit_{WasmInstr}(\seq{wi}) \\
  \hline
  \sem{\exiti}((\seq{wv}, \seq{wi}, sto), c)
  =
  ((\seq{wv'}, \seq{wi'}, sto), c') \\
%
% Replace-frame
\newline \\
\text{NOTE: $e_1$ is either store or current frame} \\
  \isframe(e_1) \quad
  \mu = \getenv(c) \quad
  v_2 = \sem{e_2}(\mu, w) \quad
  \seq{wv'} = \updatecurframe(\seq{wv}, \seq p, v_2) \\
  \hline
  \sem{\replacei ~ (e_1, \seq p, e_2)}((\seq{wv}, \seq{wi}, sto), c)
  = ((\seq{wv'}, \seq{wi}, sto), c) \\
%
% Replace-store
\newline \\
  \isstore(e_1) \quad
  \mu = \getenv(c) \quad
  v_2 = \sem{e_2}(\mu, w) \quad
  sto' = \updatestore(sto, \seq p, v_2) \\
  \hline
  \sem{\replacei ~ (e_1, \seq p, e_2)}((\seq{wv}, \seq{wi}, sto), c)
  = ((\seq{wv}, \seq{wi}, sto'), c) \\
\newline \\
\end{gather*}




%% Helper functions

\begin{gather*}
\text{NOTE: an input of is\_context (WasmValue sequence) contains at least one context} \\
%
% pop_all-ctx
\newline \\
  \text{is\_context}(\text{hd}(\seq{wv})) \\
  \hline
  \splitctx(\seq{wv}) = \epsilon, \seq{wv} \\
%
% pop_all-val
  \text{is\_not\_context}(wv_0) \quad \seq{wv_2}, \seq{wv_3} = \splitctx(\seq{wv_1}) \\
  \hline
  \splitctx(wv_0 ~ \seq{wv_1}) = wv_0 ~ \seq{wv_2}, \seq{wv_3} \\
%
% execute
\newline \\
  \execute(v, c) = \exe(v, c) \\
%
% exit_cont-wasm_0
\newline \\
\text{NOTE: input cont of exit is either \al ~ or \wasm} \\
  \exit_{Cont}(\wasm (0, c)) = \wasm(0, \exit_{Cont}(c)) \\
%
% exit_cont-wasm_nonzero
  n > 0 \\
  \hline
  \exit_{Cont}(\wasm (n, c)) = \wasm(n-1, c) \\
%
% exit_cont-al
  \exit_{Cont}(\al (\seq i, \mu, n, c)) = \al (\seq i, \mu, n, \exit(c)) \\
%
% exit_wasm_instr-end
\newline \\
  \text{is\_end}(wi) \\
  \hline
  \exit_{WasmInstr}(wi ~ \seq{wi'}) = \seq{wi'} \\
%
% exit_wasm_instr-normal_instr
  \text{is\_not\_end}(wi) \\
  \hline
  \exit_{WasmInstr}(wi ~ \seq{wi'}) = \exit_{WasmInstr}(\seq{wi'}) \\
%
% exit_wasm_value
  \seq{wv_1}, \seq{wv_2} = \splitctx(\seq{wv_0}) \\
  \hline
  \exit_{WasmValue}(\seq{wv_0}) = \text{tail}(\seq{wv_2}) \\
\end{gather*}





