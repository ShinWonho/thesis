% !TEX root = main.tex

\chapter{Evaluation}
\label{ch:eval}
\noindent


% an example of buggy test case
\textbf{Example 5.1}
\begin{verbatim}
  // function definition of $br-returning
  (func  $brAndReturning (br 0) (unreachable))

  // function call
  (call $brAndReturning)
\end{verbatim}

Example 5.1 contains a function that has only a \texttt{br} instruction, and a
\texttt{call} insstruction.
According to the \officialp{}, when the function \texttt{\$brAndReturning} is
called, a frame is pushed to the stack, and the block of the function
body is entered with a label.
When the \texttt{br} is executed, it pops the label from the stack.
As the end of the function is reached after the execution, returning from a
function is performed.
As a result, the frame is popped, so the call actually does nothing.


% explaination of the bug in SpecTec prose
\begin{align}
  &c^* \vdash call(\$brAndReturning) \label{eq:bug-1} \\
&\leadsto
  Label(\epsilon), ~ Frame, ~ c^* \vdash (br ~ 0) ~ (unreachable), ~ end \label{eq:bug-2} \\
&\leadsto
  Frame, ~ c^* \vdash \epsilon \label{eq:bug-3}
\end{align}

In \spectecp{} the call instruction in \cref{eq:bug-1} pushes a frame and
enters the function body \cref{eq:bug-2}.
When the \texttt{br} is executed, it pops the label and removes the input
instructions until the end in \cref{eq:bug-3}.
As a result, the frame is remained after the executing the call.
The problem is that the \texttt{br} should remove the end of the block but
should not remove the end of the function, but \texttt{end} express the end of
the block and the function at the same time.


% Fix
To fix the problem, semantics of \enteri is changed.
The sequence of contexts that is pushed in the AL algorithm is stored,
and when a block is entered, exiting label and returning from a function is
appended according to the sequence.


% simplified version of AL algorithm of call, br, and returning from a function
\begin{verbatim}
Call fname:
  PushCtx Frame
  Enter get_function_body(fname) with Label(\epsilon)

Br 0:
  PopCtx Label(instr*)
  ExecuteSeq instr*

Returning from a function:
  PopCtx Frame
\end{verbatim}

The code above is simplified version of \spectecp{} of \texttt{call},
\texttt{br}, and \texttt{returning from a function}.
By using the semantics defined in \cref{ch:semantics}, the example 5.1 results
in the same result with the \officialp{}; $call(\$brAndReturning)$ does
nothing.


\red{TODO: Change to array} \\
\red{TODO: Change naming for $c$}
\begin{align}
  &c^* \vdash call(\$brAndReturning); ~ \wasm ~ (\seq{c}, ~ k)
  \label{eq:resolve-1} \\
  &\leadsto c^* \vdash \epsilon; ~ \algo ~ ([ ~ \pushctxi, ~ \enteri ~ ], ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k))
  \label{eq:resolve-2} \\
  &\leadsto Frame, ~ c^* \vdash \epsilon; ~ \algo ~ ([ ~ \enteri ~ ], ~ [ ~ Frame ~ ], ~ \wasm ~ (\seq{c}, ~ k))
  \label{eq:resolve-3} \\
  &\leadsto Label(\epsilon), ~ Frame, ~ c^* \vdash (br ~ \epsilon), ~ (unreachable), ~ (exiting), ~ (returning); \\
  &\quad\quad \wasm ~ ([ ~ Label(\epsilon), ~ Frame ~ ], ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k)))
  \label{eq:resolve-4} \\
  &\leadsto Label(\epsilon), ~ Frame, ~ c^* \vdash (unreachable), ~ (exiting), ~ (returning); \\
  &\quad\quad \algo ~ ([ ~ \popctxi, ~ \executei ~ ], ~ \epsilon, ~ \wasm ~ ([ ~ Label(\epsilon), ~ Frame ~ ], ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k))))
  \label{eq:resolve-5} \\
  &\leadsto Frame, ~ c^* \vdash (returning); ~
    \algo ~ ([ ~ \executei ~ ], ~ \epsilon, ~ \wasm ~ ([ ~ Frame ~ ], ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k))))
  \label{eq:resolve-6} \\
  &\leadsto Frame, ~ c^* \vdash (returning); ~
    \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ ([ ~ Frame ~ ], ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k))))
  \label{eq:resolve-7} \\
  &\leadsto Frame, ~ c^* \vdash (returning); ~ \wasm ~ ([ ~ Frame ~ ], ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k)))
  \label{eq:resolve-8} \\
  &\leadsto Frame, ~ c^* \vdash \epsilon; ~
    \algo ~ ([ ~ \popctxi ~ ], ~ \epsilon, ~ \wasm ~ (\epsilon, ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k))))
  \label{eq:resolve-9} \\
  &\leadsto c^* \vdash \epsilon; ~
    \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\epsilon, ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k))))
  \label{eq:resolve-10} \\
  &\leadsto c^* \vdash \epsilon; ~ \wasm ~ (\epsilon, ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k)))
  \label{eq:resolve-11} \\
  &\leadsto c^* \vdash \epsilon; ~ \algo ~ (\epsilon, ~ \epsilon, ~ \wasm ~ (\seq{c}, ~ k))
  \label{eq:resolve-12} \\
  &\leadsto c^* \vdash \epsilon; ~ \wasm ~ (\seq{c}, ~ k)
  \label{eq:resolve-13}
\end{align}
